{"2017": [{"title": "Steelix: program-state based binary fuzzing", "description": "Coverage-based fuzzing is one of the most effective techniques to find vulnerabilities, bugs or crashes. However, existing techniques suffer from the difficulty in exercising the paths that are protected by magic bytes comparisons (e.g., string equality comparisons). Several approaches have been proposed to use heavy-weight program analysis to break through magic bytes comparisons, and hence are less scalable. In this paper, we propose a program-state based binary fuzzing approach, named Steelix, which improves the penetration power of a fuzzer at the cost of an acceptable slow down of the execution speed. In particular, we use light-weight static analysis and binary instrumentation to provide not only coverage information but also comparison progress information to a fuzzer. Such program state information informs a fuzzer about where the magic bytes are located in the test input and how to perform\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:ZHo1McVdvXMC"}, {"title": "Hdskg: Harvesting domain specific knowledge graph from content of webpages", "description": "Knowledge graph is useful for many different domains like search result ranking, recommendation, exploratory search, etc. It integrates structural information of concepts across multiple information sources, and links these concepts together. The extraction of domain specific relation triples (subject, verb phrase, object) is one of the important techniques for domain specific knowledge graph construction. In this research, an automatic method named HDSKG is proposed to discover domain specific concepts and their relation triples from the content of webpages. We incorporate the dependency parser with rule-based method to chunk the relations triple candidates, then we extract advanced features of these candidate relation triples to estimate the domain relevance by a machine learning algorithm. For the evaluation of our method, we apply HDSKG to Stack Overflow (a Q&A website about computer programming). As\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:cFHS6HbyZ2cC"}, {"title": "A real-time and fully distributed approach to motion planning for multirobot systems", "description": "Motion planning is one of the most critical problems in multirobot systems. The basic target is to generate a collision-free trajectory for each robot from its initial position to the target position. In this paper, we study the trajectory planning for the multirobot systems operating in unstructured and changing environments. Each robot is equipped with some sensors of limited sensing ranges. We propose a fully distributed approach to planning trajectories for such systems. It combines the model predictive control (MPC) strategy and the incremental sequential convex programming (iSCP) method. The MPC framework is applied to detect the local running environment real-timely with the concept of receding horizon. For each robot, a nonlinear programming is built in its current prediction horizon. To construct its own optimization problem, a robot first needs to communicate with its neighbors to retrieve their current states\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:zA6iFVUQeVQC"}, {"title": "Automatic loop-invariant generation anc refinement through selective sampling", "description": "Automatic loop-invariant generation is important in program analysis and verification. In this paper, we propose to generate loop-invariants automatically through learning and verification. Given a Hoare triple of a program containing a loop, we start with randomly testing the program, collect program states at run-time and categorize them based on whether they satisfy the invariant to be discovered. Next, classification techniques are employed to generate a candidate loop-invariant automatically. Afterwards, we refine the candidate through selective sampling so as to overcome the lack of sufficient test cases. Only after a candidate invariant cannot be improved further through selective sampling, we verify whether it can be used to prove the Hoare triple. If it cannot, the generated counterexamples are added as new tests and we repeat the above process. Furthermore, we show that by introducing a path-sensitive\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:3s1wT3WcHBgC"}, {"title": "FiB: Squeezing loop invariants by interpolation between forward/backward predicate transformers", "description": "Loop invariant generation is a fundamental problem in program analysis and verification. In this work, we propose a new approach to automatically constructing inductive loop invariants. The key idea is to aggressively squeeze an inductive invariant based on Craig interpolants between forward and backward reachability analysis. We have evaluated our approach by a set of loop benchmarks, and experimental results show that our approach is promising.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:u_35RYKgDlwC"}, {"title": "Learning-based compositional parameter synthesis for event-recording automata", "description": "We address the verification of timed concurrent systems with unknown or uncertain constants considered as parameters. First, we introduce parametric event-recording automata (PERAs), as a new subclass of parametric timed automata (PTAs). Although in the non-parametric setting event-recording automata yield better decidability results than timed automata, we show that the most common decision problem remains undecidable for PERAs. Then, given one set of components with parameters and one without, we propose a method to compute an abstraction of the non-parametric set of components, so as to improve the verification of reachability properties in the full (parametric) system. We also show that our method can be extended to general PTAs. We implemented our method, which shows promising results.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:HoB7MX3m0LUC"}, {"title": "Loopster: Static loop termination analysis", "description": "Loop termination is an important problem for proving the correctness of a system and ensuring that the system always reacts. Existing loop termination analysis techniques mainly depend on the synthesis of ranking functions, which is often expensive. In this paper, we present a novel approach, named Loopster, which performs an efficient static analysis to decide the termination for loops based on path termination analysis and path dependency reasoning. Loopster adopts a divide-and-conquer approach: (1) we extract individual paths from a target multi-path loop and analyze the termination of each path, (2) analyze the dependencies between each two paths, and then (3) determine the overall termination of the target loop based on the relations among paths. We evaluate Loopster by applying it on the loop termination competition benchmark and three real-world projects. The results show that Loopster is effective\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:rO6llkc54NcC"}, {"title": "Process patterns: reusable design artifacts for business process models", "description": "Graphical models for business processes are very large and cumbersome to build. Reusable process patterns can make this modeling task much easier. While using reusable components is a well-explored subject in software engineering, not much has been done in the context of business process modeling. In this paper, we will present an extension to Business Process Model and Notation (BPMN), the standard notation for modeling business processes, in the form of reusable Process Patterns. We introduce a type system for these patterns and use it to define a valid embedding of a process pattern in a larger model. We also introduce the formal notations and show that business processes modeled using our extended notation can be translated to BPMN. We present a case study to demonstrate the applicability of the process pattern and further quantify its characteristics using a set of criteria. We also implement\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:fPk4N6BV_jEC"}, {"title": "Enhancing knowledge sharing in stack overflow via automatic external web resources linking", "description": "Referencing URLs of external web resources (e.g., official language references and API documents) is an effective mechanism for knowledge sharing in Q&A websites like Stack Overflow. We show that reference frequencies of URLs follow power law distribution, meaning that web resources that have been referenced frequently will likely to be referenced again. However, there lack of effective methods to manage and reuse already-shared web resources relevant to entities (e.g., APIs or programming concepts) that are mentioned in Q&A discussions. As URL references are done in an ad-hoc manner, large amounts of entity mentions have not been linked to relevant web resources. To enhance management and reuse of alreadyshared web resources in Stack Overflow, we build a knowledge base of official documentation of languages and APIs that have been shared in Stack Overflow, and develop an automatic\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:dfsIfKJdRG4C"}], "2021": [{"title": "A survey of smart contract formal specification and verification", "description": "A smart contract is a computer program that allows users to automate their actions on the blockchain platform. Given the significance of smart contracts in supporting important activities across industry sectors including supply chain, finance, legal, and medical services, there is a strong demand for verification and validation techniques. Yet, the vast majority of smart contracts lack any kind of formal specification, which is essential for establishing their correctness. In this survey, we investigate formal models and specifications of smart contracts presented in the literature and present a systematic overview to understand the common trends. We also discuss the current approaches used in verifying such property specifications and identify gaps with the hope to recognize promising directions for future work.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:8AbLer7MMksC"}, {"title": "Pasadena: Perceptually Aware and Stealthy Adversarial Denoise Attack", "description": "Image denoising can remove natural noise that widely exists in images captured by multimedia devices due to low-quality imaging sensors, unstable image transmission processes, or low light conditions. Recent works also find that image denoising benefits the high-level vision tasks,  e.g ., image classification. In this work, we try to challenge this common sense and explore a totally new problem,  i.e ., whether the image denoising can be given the capability of fooling the state-of-the-art deep neural networks (DNNs) while enhancing the image quality. To this end, we initiate the very first attempt to study this problem from the perspective of adversarial attack and propose the  adversarial denoise attack . More specifically, our main contributions are three-fold:  First , we identify a new task that stealthily embeds attacks inside the image denoising module widely deployed in multimedia devices as an image post\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:HE397vMXCloC"}, {"title": "Formal analysis of composable DeFi protocols", "description": "Decentralized finance (DeFi) has become one of the most successful applications of blockchain and smart contracts. The DeFi ecosystem enables a wide range of crypto-financial activities, while the underlying smart contracts often contain bugs, with many vulnerabilities arising from the unforeseen consequences of composing DeFi protocols together. In this paper, we propose a formal process-algebraic technique that models DeFi protocols in a compositional manner to allow for efficient property verification. We also conduct a case study to demonstrate the proposed approach in analyzing the composition of two interacting DeFi protocols, namely, Curve and Compound. Finally, we discuss how the proposed modeling and verification approach can be used to analyze financial and security properties of interest.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:geHnlv5EZngC"}, {"title": "CSim2 Compositional Top-down Verification of Concurrent Systems using Rely-Guarantee", "description": "To make feasible and scalable the verification of large and complex concurrent systems, it is necessary the use of compositional techniques even at the highest abstraction layers. When focusing on the lowest software abstraction layers, such as the implementation or the machine code, the high level of detail of those layers makes the direct verification of properties very difficult and expensive. It is therefore essential to use techniques allowing to simplify the verification on these layers. One technique to tackle this challenge is top-down verification where by means of simulation properties verified on top layers (representing abstract specifications of a system) are propagated down to the lowest layers (that are an implementation of the top layers). There is no need to say that simulation of concurrent systems implies a greater level of complexity, and having compositional techniques to check simulation between layers\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:sSrBHYA8nusC"}, {"title": "A security type verifier for smart contracts", "description": "The widespread adoption of smart contracts demands strong security guarantees. Our work is motivated by the problem of statically checking potential information tampering in smart contracts. This paper presents a security type verification framework for smart contracts based on type systems. We introduce a formal calculus for reasoning smart contract operations and interactions and design a lightweight type system for checking secure information flow in Solidity (a popular high-level programming language for writing smart contracts). The soundness of our type system is proved wrt non-interference. In addition, a type verifier based on our type system is proposed to assist users to automatically find an optimal secure type assignment for state variables, which makes contracts well-typed. We also prove that finding the optimal secure type assignment is theoretically a NP-complete problem. We develop a prototype\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:D_sINldO8mEC"}, {"title": "Automatic HMI structure exploration via curiosity-based reinforcement learning", "description": "Discovering the underlying structure of HMI software efficiently and sufficiently for the purpose of testing without any prior knowledge on the software logic remains a difficult problem. The key challenge lies in the complexity of the HMI software and the high variance in the coverage of current methods. In this paper, we introduce the PathFinder, an effective and automatic HMI software exploration framework. PathFinder adopts a curiosity-based reinforcement learning framework to choose actions that lead to the discovery of more unknown states. Additionally, PathFinder progressively builds a navigation model during the exploration to further improve state coverage. We have conducted experiments on both simulations and real-world HMI software testing environment, which comprise a full tool chain of automobile dashboard instrument cluster. The exploration coverage outperforms manual and fuzzing methods\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:kRWSkSYxWN8C"}, {"title": "Defense for adversarial videos by self-adaptive JPEG compression and optical texture", "description": "Despite demonstrated outstanding effectiveness in various computer vision tasks, Deep Neural Networks (DNNs) are known to be vulnerable to adversarial examples. Nowadays, adversarial attacks as well as their defenses w.r.t. DNNs in image domain have been intensively studied, and there are some recent works starting to explore adversarial attacks w.r.t. DNNs in video domain. However, the corresponding defense is rarely studied. In this paper, we propose a new two-stage framework for defending video adversarial attack. It contains two main components, namely self-adaptive Joint Photographic Experts Group (JPEG) compression defense and optical texture based defense (OTD). In self-adaptive JPEG compression defense, we propose to adaptively choose an appropriate JPEG quality based on an estimation of moving foreground object, such that the JPEG compression could depress most impact of\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:eJXPG6dFmWUC"}], "2020": [{"title": "Semantic understanding of smart contracts: Executable operational semantics of solidity", "description": "Bitcoin has been a popular research topic recently. Ethereum (ETH), a second generation of cryptocurrency, extends Bitcoin's design by offering a Turing-complete programming language called Solidity to develop smart contracts. Smart contracts allow creditable execution of contracts on EVM (Ethereum Virtual Machine) without third parties. Developing correct and secure smart contracts is challenging due to the decentralized computation nature of the blockchain. Buggy smart contracts may lead to huge financial loss. Furthermore, smart contracts are very hard, if not impossible, to patch once they are deployed. Thus, there is a recent surge of interest in analyzing and verifying smart contracts. While most of the existing works either focus on EVM bytecode or translate Solidity smart contracts into programs in intermediate languages, we argue that it is important and necessary to understand and formally define the\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:OU6Ihb5iCvQC"}, {"title": "A Performance-Sensitive Malware Detection System Using Deep Learning on Mobile Devices", "description": "Currently, Android malware detection is mostly performed on server side against the increasing number of malware. Powerful computing resource provides more exhaustive protection for app markets than maintaining detection by a single user. However, apart from the applications (apps) provided by the official market (i.e., Google Play Store), apps from unofficial markets and third-party resources are always causing serious security threats to end-users. Meanwhile, it is a time-consuming task if the app is downloaded first and then uploaded to the server side for detection, because the network transmission has a lot of overhead. In addition, the uploading process also suffers from the security threats of attackers. Consequently, a last line of defense on mobile devices is necessary and much-needed. In this paper, we propose an effective Android malware detection system, MobiTive, leveraging customized deep\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:uWQEDVKXjbEC"}, {"title": "Oracle-supported dynamic exploit generation for smart contracts", "description": "Despite the high stakes involved in smart contracts, they are often developed in an undisciplined manner, leaving the security and reliability of blockchain transactions at risk. In this article, we introduce ContraMaster\u2014an oracle-supported dynamic exploit generation framework for smart contracts. Existing approaches mutate only single transactions; ContraMaster exceeds these by mutating the transaction sequences. ContraMaster uses data-flow, control-flow, and the dynamic contract state to guide its mutations. It then monitors the executions of target contract programs, and validates the results against a general-purpose semantic test oracle to discover vulnerabilities. Being a dynamic technique, it guarantees that each discovered vulnerability is a violation of the test oracle and is able to generate the attack script to exploit this vulnerability. In contrast to rule-based approaches, ContraMaster has not shown any\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:1sJd4Hv_s6UC"}, {"title": "Adversarial exposure attack on diabetic retinopathy imagery", "description": "Diabetic retinopathy (DR) is a leading cause of vision loss in the world and numerous cutting-edge works have built powerful deep neural networks (DNNs) to automatically classify the DR cases via the retinal fundus images (RFIs). However, RFIs are usually affected by the widely existing camera exposure while the robustness of DNNs to the exposure is rarely explored. In this paper, we study this problem from the viewpoint of adversarial attack and identify a totally new task, i.e., adversarial exposure attack generating adversarial images by tuning image exposure to mislead the DNNs with significantly high transferability. To this end, we first implement a straightforward method, i.e., multiplicative-perturbation-based exposure attack, and reveal the big challenges of this new task. Then, to make the adversarial image naturalness, we propose the adversarial bracketed exposure fusion that regards the exposure attack as an element-wise bracketed exposure fusion problem in the Laplacian-pyramid space. Moreover, to realize high transferability, we further propose the convolutional bracketed exposure fusion where the element-wise multiplicative operation is extended to the convolution. We validate our method on the real public DR dataset with the advanced DNNs, e.g., ResNet50, MobileNet, and EfficientNet, showing our method can achieve high image quality and success rate of the transfer attack. Our method reveals the potential threats to the DNN-based DR automated diagnosis and can definitely benefit the development of exposure-robust automated DR diagnosis method in the future.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:ZuybSZzF8UAC"}, {"title": "A distributed method to avoid higher-order deadlocks in multi-robot systems", "description": "Deadlock avoidance is a crucial problem in motion control of multi-robot systems since deadlocks can crash the systems and\u2215 or degrade their performance. However, deadlocks sometimes are difficult to predict in advance because of the existence of higher-order deadlocks, from which a system can lead to a deadlock inevitably. In this paper, we investigate the properties of higher-order deadlocks and propose a distributed approach to their avoidance in multi-robot systems where each robot has a predetermined and closed path to execute persistent motion. After modeling the motion of robots by labeled transition systems (LTSs), we first conclude that there exist at most the (N\u2212 3)-th order deadlocks with N robots. This means that deadlocks, if any, will occur unavoidably within N\u2212 3 steps of corresponding transitions. A distributed algorithm is then proposed to avoid deadlocks in such systems. In the algorithm\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:UxriW0iASnsC"}, {"title": "ModCon: A model-based testing platform for smart contracts", "description": "Unlike those on public permissionless blockchains, smart contracts on enterprise permissioned blockchains are not limited by resource constraints, and therefore often larger and more complex. Current testing and analysis tools lack support for such contracts, which demonstrate stateful behaviors and require special treatment in quality assurance. In this paper, we present a model-based testing platform, called ModCon, relying on user-specified models to define test oracles, guide test generation, and measure test adequacy. ModCon is Web-based and supports both permissionless and permissioned blockchain platforms. We demonstrate the usage and key features of ModCon on real enterprise smart contract applications.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:738O_yMBCRsC"}, {"title": "A Generalized Formal Semantic Framework for Smart Contracts.", "description": "Smart contracts can be regarded as one of the most popular blockchain-based applications. The decentralized nature of the blockchain introduces vulnerabilities absent in other programs. Furthermore, it is very difficult, if not impossible, to patch a smart contract after it has been deployed. Therefore, smart contracts must be formally verified before they are deployed on the blockchain to avoid attacks exploiting these vulnerabilities. There is a recent surge of interest in analyzing and verifying smart contracts. While most of the existing works either focus on EVM bytecode or translate Solidity contracts into programs in intermediate languages for analysis and verification, we believe that a direct executable formal semantics of the high-level programming language of smart contracts is necessary to guarantee the validity of the verification. In this work, we propose a generalized formal semantic framework based on a general semantic model of smart contracts. Furthermore, this framework can directly handle smart contracts written in different high-level programming languages through semantic extensions and facilitates the formal verification of security properties with the generated semantics.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:SP6oXDckpogC"}, {"title": "SeqMobile: An Efficient Sequence-Based Malware Detection System Using RNN on Mobile Devices", "description": "With the proliferation of Android malware, the demand for an effective and efficient malware detection system is on the rise. The existing device-end learning based solutions tend to extract limited syntax features, such as permissions and API calls, to meet a certain time constraint of mobile devices. However, unlike sequence-based features, syntax features lack the semantics which can represent the potential malicious behaviors and further result in more robust model with high accuracy for malware detection. In this paper, we propose an efficient Android malware detection system, named SeqMobile, which adopts behavior-based sequence features and leverages customized deep neural networks on mobile devices instead of the server end. Different from the traditional sequence-based approaches on server end, to meet the performance demand on mobile devices, SeqMobile accepts three effective performance\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:4fKUyHm3Qg0C"}, {"title": "Towards automated verification of smart contract fairness", "description": "Smart contracts are computer programs allowing users to define and execute transactions automatically on top of the blockchain platform. Many of such smart contracts can be viewed as games. A game-like contract accepts inputs from multiple participants, and upon ending, automatically derives an outcome while distributing assets according to some predefined rules. Without clear understanding of the game rules, participants may suffer from fraudulent advertisements and financial losses. In this paper, we present a framework to perform (semi-)automated verification of smart contract fairness, whose results can be used to refute false claims with concrete examples or certify contract implementations with respect to desired fairness properties. We implement FairCon, which is able to check fairness properties including truthfulness, efficiency, optimality, and collusion-freeness for Ethereum smart contracts. We\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:Tiz5es2fbqcC"}, {"title": "Automatic verification of multi-threaded programs by inference of rely-guarantee specifications", "description": "Rely-Guarantee is a comprehensive technique that supports compositional reasoning for concurrent programs. However, specifications of the Rely condition - environment interference, and Guarantee condition - local transformation of thread state - are challenging to establish. Thus the construction of these conditions becomes bottleneck in automating the technique. To tackle the above problem, we propose a verification framework that, based on Rely-Guarantee principles, constructs the correctness proof of concurrent program through inferring suitable Rely -Guarantee conditions automatically. Our framework first constructs a Hoare-style sequential proof for each thread and then applies abstraction refinement to elevate these proofs into concurrent ones with appropriate Rely-Guarantee relations. Experiment results demonstrate that our approach is efficient in proving the correctness of concurrent programs.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:VOx2b1Wkg3QC"}], "2019": [{"title": "Vultron: catching vulnerable smart contracts once and for all", "description": "Despite the high stakes involved, smart contracts are often developed in an undisciplined way thus far. The existence of vulnerabilities compromises the security and reliability of smart contracts, and endangers the trust of participants in their ongoing businesses. Existing vulnerability detection techniques are often designed case-by-case, making them difficult to generalize. In this paper, we design general principles for detecting vulnerable smart contracts. Our key insight is that almost all the existing transaction-related vulnerabilities are due to the mismatch between the actual transferred amount and the amount reflected on the contract's internal bookkeeping. Based on this, we propose a precise and generally applicable technique, VULTRON, which can detect irregular transactions due to various types of adversarial exploits. We also report preliminary results applying our technique to real-world case studies.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:CHSYGLWDkRkC"}, {"title": "A neural model for method name generation from functional description", "description": "The names of software artifacts, e.g., method names, are important for software understanding and maintenance, as good names can help developers easily understand others\u2019 code. However, the existing naming guidelines are difficult for developers, especially novices, to come up with meaningful, concise and compact names for the variables, methods, classes and files. With the popularity of open source, an enormous amount of project source code can be accessed, and the exhaustiveness and instability of manually naming methods could now be relieved by automatically learning a naming model from a large code repository. Nevertheless, building a comprehensive naming system is still challenging, due to the gap between natural language functional descriptions and method names. Specifically, there are three challenges: how to model the relationship between the functional descriptions and formal method\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:abG-DnoFyZgC"}, {"title": "Mobidroid: A performance-sensitive malware detection system on mobile platform", "description": "Currently, Android malware detection is mostly performed on the server side against the increasing number of Android malware. Powerful computing resource gives more exhaustive protection for Android markets than maintaining detection by a single user in many cases. However, apart from the Android apps provided by the official market (i.e., Google Play Store), apps from unofficial markets and third-party resources are always causing a serious security threat to end-users. Meanwhile, it is a time-consuming task if the app is downloaded first and then uploaded to the server side for detection because the network transmission has a lot of overhead. In addition, the uploading process also suffers from the threat of attackers. Consequently, a last line of defense on Android devices is necessary and much-needed. To address these problems, in this paper, we propose an effective Android malware detection system\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:P5F9QuxV20EC"}, {"title": "Locating vulnerabilities in binaries via memory layout recovering", "description": "Locating vulnerabilities is an important task for security auditing, exploit writing, and code hardening. However, it is challenging to locate vulnerabilities in binary code, because most program semantics (e.g., boundaries of an array) is missing after compilation. Without program semantics, it is difficult to determine whether a memory access exceeds its valid boundaries in binary code. In this work, we propose an approach to locate vulnerabilities based on memory layout recovery. First, we collect a set of passed executions and one failed execution. Then, for passed and failed executions, we restore their program semantics by recovering fine-grained memory layouts based on the memory addressing model. With the memory layouts recovered in passed executions as reference, we can locate vulnerabilities in failed execution by memory layout identification and comparison. Our experiments show that the proposed\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:xtRiw3GOFMkC"}, {"title": "Learning performance optimization from code changes for android apps", "description": "Performance issues of Android apps can tangibly degrade user experience. However, it is challenging for Android developers, especially a novice to develop high-performance apps. It is primarily attributed to the lack of consolidated and abundant programmatic guides for performance optimization. To address this challenge, we propose a data-based approach to obtain performance optimization practices from historical code changes. We first elicit performance-aware Android APIs of which invocations could affect app performance to a large extent, identify historical code changes that produce impact on app performance, and further determine whether they are optimization practices. We have implemented this approach with a tool \\tool and evaluated its effectiveness in 2 open source well-maintained projects. The experimental results found 83 changes relevant to performance optimization. Last, we summarize and\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:NhqRSupF_l8C"}, {"title": "A performance-sensitive malware detection system on mobile platform", "description": "Apart from the Android apps provided by the official market, apps from unofficial markets and third-party resources are always causing a serious security threat to end-users. Because of the overhead of the network, uploading the app to the server for detection is a time-consuming task. In addition, the uploading process also suffers from the threat of attackers. Consequently, a last line of defense on Android devices is necessary and much-needed. To address these problems, we propose an effective Android malware detection system, leveraging deep learning to provide a real-time secure and fast response environment on Android devices.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:nb7KW1ujOQ8C"}], "2004": [{"title": "VERTAF: An application framework for the design and verification of embedded real-time software", "description": "The growing complexity of embedded real-time software requirements calls for the design of reusable software components, the synthesis and generation of software code, and the automatic guarantee of nonfunctional properties such as performance, time constraints, reliability, and security. Available application frameworks targeted at the automatic design of embedded real-time software are poor in integrating functional and nonfunctional requirements. To bridge this gap, we reveal the design flow and the internal architecture of a newly proposed framework called verifiable embedded real-time application framework (VERTAF), which integrates software component-based reuse, formal synthesis, and formal verification. A formal UML-based embedded real-time object model is proposed for component reuse. Formal synthesis employs quasistatic and quasidynamic scheduling with automatic generation of\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:u5HHmVD_uO8C"}, {"title": "Formal design and verification of real-time embedded software", "description": "Currently available application frameworks that target at the automatic design of real-time embedded software are poor in integrating functional and non-functional requirements. In this work, we reveal the internal architecture and design flow of a newly proposed framework called Verifiable Embedded Real-Time Application Framework (VERTAF), which integrates three techniques namely software component-based reuse, formal synthesis, and formal verification. Component reuse is based on a formal UML real-time embedded object model. Formal synthesis employs quasi-static and quasi-dynamic scheduling with multi-layer portable efficient code generation, which can output either RTOS-specific application code or automatically-generated real-time executive with application code. Formal verification integrates a model checker kernel from SGM, by adapting it for embedded software. The proposed\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:Y0pCki6q_DkC"}, {"title": "Automatic synthesis and verification of Real-Time Embedded software", "description": "Currently available application frameworks that target at the automatic design of real-time embedded software are poor in integrating functional and non-functional requirements. In this work, we reveal the internal architecture and design flow of a newly proposed framework called Verifiable Embedded Real-Time Application Framework (VERTAF), which integrates software component-based reuse, formal synthesis, and formal verification. Component reuse is based on a formal UML real-time embedded object model. Formal synthesis employs quasi-static and quasi-dynamic scheduling with multi-layer portable efficient code generation, which can output either RTOS-specific application code or automatically-generated real-time executive with application code. Formal verification integrates a model checker kernel from SGM, by adapting it for embedded software. Application examples developed using\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:5awf1xo2G04C"}], "2018": [{"title": "A distributed approach to robust control of multi-robot systems", "description": "Motion planning of multi-robot systems has been extensively investigated. Many proposed approaches assume that all robots are reliable. However, robots with priori known levels of reliability may be used in applications to account for: (1) the cost in terms of unit price per robot type, and (2) the cost in terms of robot wear in long term deployment. In the former case, higher reliability comes at a higher price, while in the latter replacement may cost more than periodic repairs, e.g., buses, trams, and subways. In this study, we investigate robust control of multi-robot systems, such that the number of robots affected by the failed ones is minimized. It should mandate that the failure of a robot can only affect the motion of robots that collide directly with the failed one. We assume that the robots in a system are divided into reliable and unreliable ones, and each robot has a predetermined and closed path to execute persistent\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:_xSYboBqXhAC"}, {"title": "Quasi-open bisimilarity with mismatch is intuitionistic", "description": "Quasi-open bisimilarity is the coarsest notion of bisimilarity for the \u03c0-calculus that is also a congruence. This work extends quasi-open bisimilarity to handle mismatch (guards with inequalities). This minimal extension of quasi-open bisimilarity allows fresh names to be manufactured to provide constructive evidence that an inequality holds. The extension of quasi-open bisimilarity is canonical and robust --- coinciding with open barbed bisimilarity (an objective notion of bisimilarity congruence) and characterised by an intuitionistic variant of an established modal logic. The more famous open bisimilarity is also considered, for which the coarsest extension for handling mismatch is identified. Applications to checking privacy properties are highlighted. Examples and soundness results are mechanised using the proof assistant Abella.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:f2IySw72cVMC"}, {"title": "APIReal: an API recognition and linking approach for online developer forums", "description": "When discussing programming issues on social platforms (e.g, Stack Overflow, Twitter), developers often mention APIs in natural language texts. Extracting API mentions from natural language texts serves as the prerequisite to effective indexing and searching for API-related information in software engineering social content. The task of extracting API mentions from natural language texts involves two steps: 1) distinguishing API mentions from other English words (i.e., API recognition), 2) disambiguating a recognized API mention to its unique fully qualified name (i.e., API linking). Software engineering social content lacks consistent API mentions and sentence writing format. As a result, API recognition and linking have to deal with the inherent ambiguity of API mentions in informal text, for example, due to the ambiguity between the API sense of a common word and the normal sense of the word (e.g\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:yD5IFk8b50cC"}, {"title": "Compositional reasoning for shared-variable concurrent programs", "description": "Scalable and automatic formal verification for concurrent systems is always demanding. In this paper, we propose a verification framework to support automated compositional reasoning for concurrent programs with shared variables. Our framework models concurrent programs as succinct automata and supports the verification of multiple important properties. Safety verification and simulations of succinct automata are parallel compositional, and safety properties of succinct automata are preserved under refinements. We generate succinct automata from infinite state concurrent programs in an automated manner. Furthermore, we propose the first automated approach to checking rely-guarantee based simulations between infinite state concurrent programs. We have prototyped our algorithms and applied our tool to the verification of multiple refinements.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:b0M2c_1WBrUC"}, {"title": "The language preservation problem is undecidable for parametric event-recording automata", "description": "Parametric timed automata (PTA) extend timed automata with unknown constants (\u201cparameters\u201d), at the price of undecidability of most interesting problems. The (untimed) language preservation problem (\u201cgiven a parameter valuation, can we find at least one other valuation with the same untimed language?\u201d) is undecidable for PTAs. We prove that this problem remains undecidable for parametric event-recording automata (PERAs), a subclass of PTAs that considerably restrains the way the language can be used; we also show it remains undecidable even for slightly different definitions of the language, i.e., finite sequences of actions ending in or passing infinitely often through accepting locations, or just all finite untimed words (without accepting locations).", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:a0OBvERweLwC"}, {"title": "An Executable Operational Semantics for Rust with the Formalization of Ownership and Borrowing", "description": "Rust is an emergent systems programming language highlighting memory safety by its Ownership and Borrowing System (OBS). The existing formal semantics for Rust only covers limited subsets of the major language features of Rust. Moreover, they formalize OBS as type systems at the language-level, which can only be used to conservatively analyze programs against the OBS invariants at compile-time. That is, they are not executable, and thus cannot be used for automated verification of runtime behavior. In this paper, we propose RustSEM, a new executable operational semantics for Rust. RustSEM covers a much larger subset of the major language features than existing semantics. Moreover, RustSEM provides an operational semantics for OBS at the memory-level, which can be used to verify the runtime behavior of Rust programs against the OBS invariants. We have implemented RustSEM in the executable semantics modeling tool K-Framework. We have evaluated the semantics correctness of RustSEM wrt. the Rust compiler using around 700 tests. In particular, we have proposed a new technique for testing semantic consistency to ensure the absence of semantic ambiguities on all possible execution selections. We have also evaluated the potential applications of RustSEM in automated runtime and formal verification for both functional and memory properties. Experimental results show that RustSEM can enhance the memory safety mechanism of Rust, as it is more powerful than OBS in detecting memory errors.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:ye4kPcJQO24C"}], "2014": [{"title": "Learning Assumptions for Compositional Verification of Timed Systems", "description": "Compositional techniques such as assume-guarantee reasoning (AGR) can help to alleviate the state space explosion problem associated with model checking. However, compositional verification is difficult to be automated, especially for timed systems, because constructing appropriate assumptions for AGR usually requires human creativity and experience. To automate compositional verification of timed systems, we propose a compositional verification framework using a learning algorithm for automatic construction of timed assumptions for AGR. We prove the correctness and termination of the proposed learning-based framework, and experimental results show that our method performs significantly better than traditional monolithic timed model checking.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:0EnyYjriUFMC"}, {"title": "Diamonds are a girl\u2019s best friend: Partial order reduction for timed automata with abstractions", "description": "A major obstacle for using partial order reduction in the context of real time verification is that the presence of clocks and clock constraints breaks the usual diamond structure of otherwise independent transitions. This is especially true when information of the relative values of clocks is preserved in the form of diagonal constraints. However, when diagonal constraints are relaxed by a suitable abstraction, some diamond structure is re-introduced in the zone graph. In this article, we introduce a variant of the stubborn set method for reducing an abstracted zone graph. Our method works with all abstractions, but especially targets situations where one abstract execution can simulate several permutations of the corresponding concrete execution, even though it might not be able to simulate the permutations of the abstract execution. We define independence relations that capture this \u201chidden\u201d diamond structure\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:M3NEmzRMIkIC"}, {"title": "Compositional synthesis of concurrent systems through causal model checking and learning", "description": "Formal verification such as model checking can be used to verify whether a system model satisfies a given specification. However, if model checking shows that the system model violates the specification, the designer has to manually refine the system model. To automate this refinement process, we propose a learning-based synthesis framework that can automatically eliminate all counterexamples from a system model based on causality semantics such that the synthesized model satisfies a given safety specification. Further, the framework for synthesis is not only automatic, but is also an iterative compositional process based on the L* algorithm, i.e., the global state space of the system is never generated in the synthesis process. We also prove the correctness and termination of the synthesis framework.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:maZDTaKrznsC"}], "2013": [{"title": "Tzuyu: Learning stateful typestates", "description": "Behavioral models are useful for various software engineering tasks. They are, however, often missing in practice. Thus, specification mining was proposed to tackle this problem. Existing work either focuses on learning simple behavioral models such as finite-state automata, or relies on techniques (e.g., symbolic execution) to infer finite-state machines equipped with data states, referred to as stateful typestates. The former is often inadequate as finite-state automata lack expressiveness in capturing behaviors of data-rich programs, whereas the latter is often not scalable. In this work, we propose a fully automated approach to learn stateful typestates by extending the classic active learning process to generate transition guards (i.e., propositions on data states). The proposed approach has been implemented in a tool called TzuYu and evaluated against a number of Java classes. The evaluation results show that\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:j3f4tGmQtD8C"}, {"title": "PSyHCoS: parameter synthesis for hierarchical concurrent real-time systems", "description": "Real-time systems are often hard to control, due to their complicated structures, quantitative time factors and even unknown delays. We present here PSyHCoS, a tool for analyzing parametric real-time systems specified using the hierarchical modeling language PSTCSP. PSyHCoS supports several algorithms for parameter synthesis and model checking, as well as state space reduction techniques. Its architecture favors reusability in terms of syntax, semantics, and algorithms. It comes with a friendly user interface that can be used to edit, simulate and verify PSTCSP models. Experiments show its efficiency and applicability.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:M3ejUd6NZC8C"}, {"title": "CELL: A Compositional Verification Framework", "description": "This paper presents CELL, a comprehensive and extensible framework for compositional verification of concurrent and real-time systems based on commonly used semantic models. For each semantic model, CELL offers three libraries, i.e., compositional verification paradigms, learning algorithms and model checking methods to support various state-of-the-art compositional verification approaches. With well-defined APIs, the framework could be applied to build customized model checkers. In addition, each library could be used independently for verification and program analysis purposes. We have built three model checkers with CELL. The experimental results show that the performance of these model checkers can offer similar or often better performance compared to the state-of-the-art verification tools.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:TQgYirikUcIC"}, {"title": "Generating C# Programs from CSP# Models", "description": "Due to the inherent complexity of the concurrent behavior, it is difficult to ensure the program satisfies the concurrent properties. CSP#, as a formal language, is used to model the program and the properties can be verified on the CSP# model. It is desirable to have a transformation technique from the CSP# model to the implementation. We implement the CSP# operators in a C# library \u201cPAT.Runtime\u201d. Based on it, a code generation tool is developed in PAT framework to transform CSP# models to multi-threaded C# programs. We prove that the generated C# program and original CSP# model are equivalent on the traces semantics. The validated properties of the CSP# model preserve in the generated program.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:ZeXyd9-uunAC"}], "2011": [{"title": "An efficient algorithm for learning event-recording automata", "description": "In inference of untimed regular languages, given an unknown language to be inferred, an automaton is constructed to accept the unknown language from answers to a set of membership queries each of which asks whether a string is contained in the unknown language. One of the most well-known regular inference algorithms is the L* algorithm, proposed by Angluin in 1987, which can learn a minimal deterministic finite automaton (DFA) to accept the unknown language. In this work, we propose an efficient polynomial time learning algorithm, TL*, for timed regular language accepted by event-recording automata. Given an unknown timed regular language, TL* first learns a DFA accepting the untimed version of the timed language, and then passively refines the DFA by adding time constraints. We prove the correctness, termination, and minimality of the proposed TL* algorithm.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:WF5omc3nYNoC"}, {"title": "VERTAF/Multi-Core: A SysML-based application framework for multi-core embedded software development", "description": "Multi-core processors are becoming prevalent rapidly in personal computing and embedded systems. Nevertheless, the programming environment for multi-core processor-based systems is still quite immature and lacks efficient tools. In this work, we present a new VERTAF/Multi-Core framework and show how software code can be automatically generated from SysML models of multi-core embedded systems. We illustrate how model-driven design based on SysML can be seamlessly integrated with Intel\u2019s threading building blocks (TBB) and the quantum framework (QF) middleware. We use a digital video recording system to illustrate the benefits of the framework. Our experiments show how SysML/QF/TBB help in making multi-core embedded system programming model-driven, easy, and efficient.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:2osOgNQ5qMEC"}, {"title": "Counterexample-guided assume-guarantee synthesis through learning", "description": "Assume-guarantee reasoning (AGR) is a promising compositional verification technique that can address the state space explosion problem associated with model checking. Since the construction of assumptions usually requires nontrivial human efforts, a framework was already proposed for generating assumptions automatically using the L* algorithm. However, if the framework shows that a system model does not satisfy a given specification, the designer has to manually refine the system model. To automate this refinement process, we propose a framework that can automatically eliminate all counterexamples from a system model such that the synthesized model satisfies a given safety specification. Further, the framework for synthesis is not only automatic, but is also an iterative L*-based compositional process, i.e., the global state space of the system is never generated in the synthesis process. When a model\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:Tyk-4Ss8FVUC"}, {"title": "SAT-based Verification of Data-Independent Access Control Security Systems", "description": "The Harrison-Ruzzo-Ullman problem is the verification of a set of policy rules, starting from an initial protection matrix, for the reachability of a state in which a generic access right is granted. Three decades ago, it was shown to be undecidable; however, recently Kleiner and Newcomb (KN) used communicating sequential processes to prove that the model checking of data-independent security systems against universal safety access temporal logic (SATL) is decidable. Nevertheless, this restricted KN problem still lacks an automatic verification method. As a solution, we modeled it as a satisfiability problem such that a set of policy rules can be model checked against a universal SATL property without explicitly constructing the state model a priori. This is made possible by a key technique called permission inheritance. Besides proving the correctness and termination of the proposed method, two real cases namely employee information system and nuclear power plant security system are also used to illustrate the feasibility and efficiency of the proposed method.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:hqOjcs7Dif8C"}, {"title": "Automatic High-Level Code Generation for Multi-Core Processors in Embedded Systems", "description": "This chapter demonstrates how high-level code is automatically generated for multi-core processors. The code generation capability of the Verifiable Embedded Real-Time Application Framework (VERTAF) was extended to support multi-core processors in the new VERTAF/Multi-Core (VMC) framework for embedded systems. After users specify embedded software requirements via SysML models along with parallel task, parallel data, and parallel dataflow specifications, the code generator automatically generates parallel code. Using the digital video recording (DVR) system as a case study, we show the correctness and advantages of the VMC code generator. The main inputs of VMC code generator include the block definition diagrams, state machine diagrams, and requirement diagrams of the system to be designed. The proposed code generation in VMC not only significantly decreases the amount of manually-written code, but also provides a formal procedure for model-conforming code generation of multi-core embedded software.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:eq2jaN3J8jMC"}, {"title": "Model-Driven Development of Multi-Core Embedded Software", "description": "Multi-core processors are becoming prevalent rapidly in personal computing and embedded systems. Nevertheless, the programming environment for multi-core processor based systems is still quite immature and lacks efficient tools. This chapter will propose a new framework called VERTAF/Multi-Core (VMC) and show how software code can be automatically generated from high-level SysML models of multi-core embedded systems. It will also illustrate how model-driven design based on SysML can be seamlessly integrated with Intel\u2019s Threading Building Blocks (TBB) and Quantum Platform (QP) middleware. Finally, this chapter will use a digital video recording (DVR) system to illustrate the benefits of the proposed VMC framework.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:p2g8aNsByqUC"}], "2005": [{"title": "Model checking prioritized timed automata", "description": "Priorities are often used to resolve conflicts in timed systems. However, priorities are not directly supported by state-of-art model checkers. Often, a designer has to either abstract the priorities leading to a high degree of non-determinism or model the priorities using existing primitives. In this work, it is shown how prioritized timed automata can make modelling prioritized timed systems easier through the support for priority specification and model checking. The verification of prioritized timed automata requires a subtraction operation to be performed on two clock zones, represented by DBMs, for which we propose an algorithm to generate the minimal number of zones partitioned. After the application of a series of DBM subtraction operations, the number of zones generated become large. We thus propose an algorithm to reduce the final number of zones partitioned by merging some of them. A typical bus\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:u-x6o8ySG0sC"}, {"title": "Model checking timed systems with priorities", "description": "Priorities are used to resolve conflicts such as in re-source sharing and in safety designs. The use of priorities has become indispensable in real-time system design such as in scheduling, synchronization, arbitration, and fairness guaranteeing. There are several modeling frameworks that show how timed systems with priorities are to be designed and how priority schedulers can be automatically synthesized. However, the verification of timed systems with priorities using model checking is still a relatively untouched area. We show what the issues are in model checking timed systems with priorities and how the issues are solved in this work. In the process, we propose an optimal zone subtraction algorithm. The method has been implemented into the SGM model checker and successfully applied to real-time embedded systems and safety-critical systems, which illustrate the feasibility and advantages of the proposed\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:9yKSN-GCB0IC"}], "2012": [{"title": "Automatic Compositional Verification of Timed Systems", "description": "Specification and verification of real-time systems are important research topics with crucial applications; however, the so-called state space explosion problem often prevents model checking to be used in practice for large systems. In this work, we present a self-contained toolkit to analyze real-time systems specified using event-recording automata (ERAs), which supports system modeling, animated simulation, and fully automatic compositional verification based on learning techniques. Experimental results show that our tool outperforms the state-of-the-art timed model checker.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:3fE2CSJIrl8C"}, {"title": "Automatic generation of provably correct embedded systems", "description": "With the demand for new and complicated features, embedded systems are becoming more and more difficult to design and verify. Even if the design of a system is verified, how to guarantee the consistency between the design and its implementation remains a big issue. As a solution, we propose a framework that can help a system designer to model his or her embedded system using a high-level modeling language, verify the design of the system, and automatically generate executable software codes whose behavior semantics are consistent with that of the high-level model. We use two case studies to demonstrate the effectiveness of our framework.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:MXK_kJrjxJIC"}, {"title": "Model Checking Prioritized Timed Systems", "description": "Real-time systems modeled by timed automata are often symbolically verified using Difference Bound Matrix (DBM) and Binary Decision Diagram (BDD) operations. When designing concurrent real-time systems with two or more processes sharing a resource, priorities are often used to schedule processes and to resolve conflicting resource requests. Concurrent real-time systems can thus be modeled by timed automata with priorities. However, model checking timed automata with priorities needs the DBM subtraction operation, whose result may not be convex, i.e., DBMs are not closed under subtraction. Thus, a partition of the resulting DBM is required. In this work, we propose Prioritized Timed Automata (PTA) and resolve all the issues related to the model checking of PTA. Two algorithms are proposed including an optimal DBM subtraction algorithm that produces the minimal number of DBM partitions, and a\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:LkGwnXOMwfcC"}], "2015": [{"title": "Interpolation guided compositional verification (t)", "description": "Model checking suffers from the state space explosion problem. Compositional verification techniques such as assume-guarantee reasoning (AGR) have been proposed to alleviate the problem. However, there are at least three challenges in applying AGR. Firstly, given a system M1 ? M2, how do we automatically construct and refine (in the presence of spurious counterexamples) an assumption A2, which must be an abstraction of M2? Previous approaches suggest to incrementally learn and modify the assumption through multiple invocations of a model checker, which could be often time consuming. Secondly, how do we keep the state space small when checking M1 ? A2 = f if multiple refinements of A2 are necessary? Lastly, in the presence of multiple parallel components, how do we partition the components? In this work, we propose interpolation-guided compositional verification. The idea is to tackle three\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:vV6vV6tmYwMC"}, {"title": "TLV: abstraction through testing, learning, and validation", "description": "A (Java) class provides a service to its clients (i.e., programs which use the class). The service must satisfy certain specifications. Different specifications might be expected at different levels of abstraction depending on the client's objective. In order to effectively contrast the class against its specifications, whether manually or automatically, one essential step is to automatically construct an abstraction of the given class at a proper level of abstraction. The abstraction should be correct (i.e., over-approximating) and accurate (i.e., with few spurious traces). We present an automatic approach, which combines testing, learning, and validation, to constructing an abstraction. Our approach is designed such that a large part of the abstraction is generated based on testing and learning so as to minimize the use of heavy-weight techniques like symbolic execution. The abstraction is generated through a process of abstraction\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:RYcK_YlVTxYC"}], "2022": [{"title": "Enhancing security patch identification by capturing structures in commits", "description": "With the rapid increasing number of open source software (OSS), the majority of the software vulnerabilities in the open source components are fixed silently, which leads to the deployed software that integrated them being unable to get a timely update. Hence, it is critical to design a security patch identification system to ensure the security of the utilized software. However, most of the existing works for security patch identification just consider the changed code and the commit message of a commit as a flat sequence of tokens with simple neural networks to learn its semantics, while the structure information is ignored. To address these limitations, in this paper, we propose our well-designed approach E-SPI, which extracts the structure information hidden in a commit for effective identification. Specifically, it consists of the code change encoder to extract the syntactic of the changed code with the BiLSTM to learn the\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:XiVPGOgt02cC", "topics": "Information Retrieval, Software Engineering"}, {"title": "Finding Permission Bugs in Smart Contracts with Role Mining", "description": "Smart contracts deployed on permissionless blockchains, such as Ethereum, are accessible to any user in a trustless environment. Therefore, most smart contract applications implement access control policies to protect their valuable assets from unauthorized accesses. A difficulty in validating the conformance to such policies, i.e., whether the contract implementation adheres to the expected behaviors, is the lack of policy specifications. In this paper, we mine past transactions of a contract to recover a likely access control model, which can then be checked against various information flow policies and identify potential bugs related to user permissions. We implement our role mining and security policy validation in tool SPCon. The experimental evaluation on labeled smart contract role mining benchmark demonstrates that SPCon effectively mines more accurate user roles compared to the state-of-the-art role mining\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:5ugPr518TE4C", "topics": "Access Control, Role Mining, Smart Contracts"}, {"title": "A quantum interpretation of separating conjunction for local reasoning of quantum programs based on separation logic", "description": "It is well-known that quantum programs are not only complicated to design but also challenging to verify because the quantum states can have exponential size and require sophisticated mathematics to encode and manipulate. To tackle the state-space explosion problem for quantum reasoning, we propose a Hoare-style inference framework that supports local reasoning for quantum programs. By providing a quantum interpretation of the separating conjunction, we are able to infuse separation logic into our framework and apply local reasoning using a quantum frame rule that is similar to the classical frame rule. For evaluation, we apply our framework to verify various quantum programs including Deutsch\u2013Jozsa\u2019s algorithm and Grover's algorithm.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:mvPsJ3kp5DgC", "topics": "Quantum Programming, Separation Logic, Local Reasoning"}, {"title": "SolSEE: a source-level symbolic execution engine for solidity", "description": "Most of the existing smart contract symbolic execution tools perform analysis on bytecode, which loses high-level semantic information presented in source code. This makes interactive analysis tasks\u2014such as visualization and debugging\u2014extremely challenging, and significantly limits the tool usability. In this paper, we present SolSEE, a source-level symbolic execution engine for Solidity smart contracts. We describe the design of SolSEE, highlight its key features, and demonstrate its usages through a Web-based user interface. SolSEE demonstrates advantages over other existing source-level analysis tools in the advanced Solidity language features it supports and analysis flexibility. A demonstration video is available at: https://sites.google.com/view/solsee/.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:olpn-zPbct0C", "topics": "Symbolic Execution, Smart Contracts, Solidity"}, {"title": "Property-Based Automated Repair of DeFi Protocols", "description": "Programming errors enable security attacks on smart contracts, which are used to manage large sums of financial assets. Automated program repair (APR) techniques aim to reduce developers\u2019 burden of manually fixing bugs by automatically generating patches for a given issue. Existing APR tools for smart contracts focus on mitigating typical smart contract vulnerabilities rather than violations of functional specification. However, in decentralized financial (DeFi) smart contracts, the inconsistency between intended behavior and implementation translates into the deviation from the underlying financial model, resulting in monetary losses for the application and its users. In this work, we propose DeFinery\u2014a technique for automated repair of a smart contract that does not satisfy a user-defined correctness property. To explore a larger set of diverse patches while providing formal correctness guarantees w.r.t. the\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:t6usbXjVLHcC", "topics": "Automated Program Repair, Smart Contracts, Decentralized Finance"}, {"title": "SMT Solver with Hardware Acceleration", "description": "Satisfiability modulo theories (SMT), an extension of Boolean satisfiability (SAT) problem, is widely used in many application domains because of its rich expressiveness. Thus, there are many works trying to speedup the process of SAT/SMT solving. In this work, we develop a framework by proposing a new hardware architecture to solve the SMT problem for the theory of Quantifier free Linear Real Arithmetic (QF-LRA) to speedup the SMT solving process. The new proposed architecture framework consists of a hardware SAT solver and a hardware Simplex solver. Our hardware SAT solver has an optimized BCP process with a pipeline structure and a non-chronological backtracking mechanism, while our hardware Simplex solver supports parallel operation flow inside the Simplex iteration to execute the selection operations parallelly with the pivot operation and the row selection mechanism to avoid unnecessary\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:Mojj43d5GZwC", "topics": "Hardware Acceleration, SMT Solver, SAT/SMT Solving"}, {"title": "Dynamic assertion for quantum circuits based on stabilizers", "description": "Quantum computing is computationally more powerful than classical one due to the features of superposition and entanglement of quantum bits (qubits). However, because of the non-cloning property, measuring qubits in superposition forces them to collapse onto classical ones, which makes traditional run-time techniques for debugging and analyzing hardware circuits infeasible. To overcome this issue, previous works proposed the concept of quantum dynamic runtime assertion. Stabilizer is an approach adopted for correcting quantum errors. The quantum state can remain unchanged after several Pauli operations. We call these Pauli operations a stabilizer. In this work, we propose to use the quantum stabilizers for dynamic runtime assertions, which requires less quantum gates and increases the detect accuracy on Noisy intermediate scale quantum(NISQ).", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:UHK10RUVsp4C", "topics": "Quantum Computing, Quantum Error Correction, Dynamic Runtime Assertion"}], "2009": [{"title": "Model-driven development of multi-core embedded software", "description": "Model-driven development is worthy of further research because of its proven capabilities in increasing productivity and ensuring correctness. However, it has not yet been explored for multi-core processor-based embedded systems, whose programming is even more complex and difficult that that for conventional uni-processor systems. We propose a new VERTAF/Multi-Core (VMC) framework to bridge this gap. In this work, we mainly show how VMC generates code automatically from user-specified SysML models for multi-core embedded systems. We illustrate how model-driven design based on SysML can be seamlessly integrated with Intels threading building blocks (TBB) and the Quantum Framework middleware. We use a digital video recording system to illustrate the benefits of VMC. Our experiments show how SysML/QF/TBB make multi-core embedded system programming easy, efficient, and effortless.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:zYLM7Y9cAGgC"}, {"title": "Vertaf/multi-core: A sysml-based application framework for multi-core embedded software development", "description": "Multi-core processors are becoming prevalent rapidly in personal computing and embedded systems. Nevertheless, the programming environment for multi-core processor based systems is still quite immature and lacks efficient tools. In this work, we present a new VERTAF/Multi-Core framework and show how software code can be automatically generated from SysML models of multi-core embedded systems. We illustrate how model-driven design based on SysML can be seamlessly integrated with Intel\u2019s threading building blocks (TBB) and the Quantum Platform middleware. We use a digital video recording system to illustrate the benefits of the framework. Our experiments show how SysML/QF/TBB help in making the multi-core embedded system programming model-driven, easy, efficient, and effortless.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:W7OEmFMy1HYC"}, {"title": "Modeling and verification of real-time embedded systems with urgency", "description": "Real-time embedded systems are often designed with different types of urgencies such as delayable or eager, that are modeled by several urgency variants of the timed automata model. However, most model checkers do not support such urgency semantics, except for the IF toolset that model checks timed automata with urgency against observers. This work proposes an Urgent Timed Automata (UTA) model with zone-based urgency semantics that gives the same model checking results as absolute urgency semantics of other existing urgency variants of the timed automata model, including timed automata with deadlines and timed automata with urgent transitions. A necessary and sufficient condition, called complete urgency, is formulated and proved for avoiding zone partitioning so that the system state graphs are simpler and model checking is faster. A novel zone capping method is proposed that is time\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:YsMSGLbcyi4C"}], "2010": [{"title": "Real-time embedded software design for mobile and ubiquitous systems", "description": "Currently available application frameworks that target at the automatic design of real-time embedded software are poor in integrating functional and non-functional requirements for mobile and ubiquitous systems. In this work, we present the internal architecture and design flow of a newly proposed framework called Verifiable Embedded Real-Time Application Framework (VERTAF), which integrates three techniques namely software component-based reuse, formal synthesis, and formal verification. The proposed architecture for VERTAF is component-based which allows plug-and-play for the scheduler and the verifier. The architecture is also easily extensible because reusable hardware and software design components can be added. Application examples developed using VERTAF demonstrate significantly reduced relative design effort, which shows how high-level reuse of software components\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:eQOLeE2rZwMC"}], "2008": [{"title": "Automatic synthesis and verification of real-time embedded software for mobile and ubiquitous systems", "description": "Currently available application frameworks that target the automatic design of real-time embedded software are poor in integrating functional and non-functional requirements for mobile and ubiquitous systems. In this work, we present the internal architecture and design flow of a newly proposed framework called Verifiable Embedded Real-Time Application Framework (VERTAF), which integrates three techniques namely software component-based reuse, formal synthesis, and formal verification. Component reuse is based on a formal unified modeling language (UML) real-time embedded object model. Formal synthesis employs quasi-static and quasi-dynamic scheduling with multi-layer portable efficient code generation, which can output either real-time operating systems (RTOS)-specific application code or automatically generated real-time executive with application code. Formal verification integrates a model\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:d1gkVwhDpl0C"}], "2016": [{"title": "From verified model to executable program: the PAT approach", "description": "CSP# is a formal modeling language that emphasizes the design of communication in concurrent systems. PAT framework provides a model checking environment for the simulation and verification of CSP# models. Although the desired properties can be formally verified at the design level, it is not always straightforward to ensure the correctness of the system\u2019s implementation conforms to the behaviors of the formal design model. To avoid human error and enhance productivity, it would be beneficial to have a tool support to automatically generate the executable programs from their corresponding formal models. In this paper, we propose such a solution for translating verified CSP# models into C# programs in the PAT framework. We encoded the CSP# operators in a C# library-\u201cPAT.Runtime\u201d, where the event synchronization is based on the \u201cMonitor\u201d class in C#. The precondition and choice layers are\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:lSLTfruPkqcC"}, {"title": "Engineering Socially-Aware Systems and Applications", "description": "With the convergence of pervasive mobile computing and social networking, interest has grown significantly in software systems and applications that are aware of users' social context to make pervasive applications more intelligent and accessible. Thus, socially-aware systems have further advanced context-aware systems taking account of human social context such as social relationships to enable the attainment of users' tasks in different domains. However, social context-awareness introduces a variety of software engineering challenges. In this paper, we address these challenges by proposing a software engineering process that provides a methodological framework for developing various types of socially-aware applications from requirements elicitation through to concrete implementation. We provide context models and software infrastructure to assist developers in rapid prototyping. We also present two\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:4OULZ7Gr8RgC"}], "2006": [{"title": "Model checking timed systems with urgencies", "description": "Computation tree logic (CTL) model checkers either allow modeling of only lazy semantics in the timed system model or consider at most a simple as soon as possible semantics. However, the design of real-time systems requires different types of urgencies, which have been modeled by several urgency variants of the timed automata model. Except for the IF toolset that model checks timed automata with urgency against observers, the urgency variants of timed automata have not yet been used for verifying the satisfaction of CTL properties in real-time systems. This work is targeted at proposing a zone-based urgency semantics that is time-reactive and at model checking timed automata models that have been extended with such urgency semantics for delayable and eager transition types. Interactions among these different types of transition urgencies are also investigated. The proposed verification\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:qjMakFHDy7sC"}], "2007": [{"title": "Real-time embedded software design for mobile and ubiquitous systems", "description": "Currently available application frameworks that target at the automatic design of real-time embedded software are poor in integrating functional and non-functional requirements for mobile and ubiquitous systems. In this work, we present the internal architecture and design flow of a newly proposed framework called Verifiable Embedded Real-Time Application Framework (VERTAF), which integrates three techniques namely software component-based reuse, formal synthesis, and formal verification. The proposed architecture for VERTAF is component-based which allows plug-and-play for the scheduler and the verifier. The architecture is also easily extensible because reusable hardware and software design components can be added. Application examples developed using VERTAF demonstrate significantly reduced relative design effort, which shows how high-level reuse of software components\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:SdhP9T11ey4C"}, {"title": "From ISA to application design via RTOS\u2014a course design framework for embedded software", "description": "Embedded systems have pervaded every aspect of our daily lives, however their design and verification are often accomplished using ad hoc and trial-and-error methods. Courses introducing systematic and more formal methods are required. However, currently there is little consensus on what a standard syllabus for an undergraduate course on embedded software design should cover. This paper proposes a course design that have undergone thorough experimentations and evaluations through the last four years in actual classes. The course starts from the ARM instruction set architecture and concludes with an introduction of Java-based wireless application design. The design of standalone, as well as, RTOS-based embedded software are all introduced. The course has culminated in the generation of embedded software engineers that significantly contribute to the technical industry in Taiwan, spanning from\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:roLk4NBRz8UC"}], "2023": [{"title": "A Quantum SMT Solver for Bit-Vector Theory", "description": "Given a formula  of satisfiability modulo theory (SMT), the classical SMT solver tries to (1) abstract  as a Boolean formula , (2) find a Boolean solution to , and (3) check whether the Boolean solution is consistent with the theory. Steps~{(2)} and (3) may need to be performed back and forth until a consistent solution is found. In this work, we develop a quantum SMT solver for the bit-vector theory. With the characteristic of superposition in quantum system, our solver is able to consider all the inputs simultaneously and check their consistency between Boolean and the theory domains in one shot.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:LjlpjdlvIbIC"}, {"title": "A Parallel and Distributed Quantum SAT Solver Based on Entanglement and Quantum Teleportation", "description": "Boolean satisfiability (SAT) solving is a fundamental problem in computer science. Finding efficient algorithms for SAT solving has broad implications in many areas of computer science and beyond. Quantum SAT solvers have been proposed in the literature based on Grover's algorithm. Although existing quantum SAT solvers can consider all possible inputs at once, they evaluate each clause in the formula one by one sequentially, making the time complexity O(m) -- linear to the number of clauses m -- per Grover iteration. In this work, we develop a parallel quantum SAT solver, which reduces the time complexity in each iteration from linear time O(m) to constant time O(1) by utilising extra entangled qubits. To further improve the scalability of our solution in case of extremely large problems, we develop a distributed version of the proposed parallel SAT solver based on quantum teleportation such that the total qubits required are shared and distributed among a set of quantum computers (nodes), and the quantum SAT solving is accomplished collaboratively by all the nodes. We have proved the correctness of our approaches and demonstrated them in simulations.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:W5xh706n7nkC"}], "2017": [{"title": "Steelix: program-state based binary fuzzing", "description": "Coverage-based fuzzing is one of the most effective techniques to find vulnerabilities, bugs or crashes. However, existing techniques suffer from the difficulty in exercising the paths that are protected by magic bytes comparisons (e.g., string equality comparisons). Several approaches have been proposed to use heavy-weight program analysis to break through magic bytes comparisons, and hence are less scalable. In this paper, we propose a program-state based binary fuzzing approach, named Steelix, which improves the penetration power of a fuzzer at the cost of an acceptable slow down of the execution speed. In particular, we use light-weight static analysis and binary instrumentation to provide not only coverage information but also comparison progress information to a fuzzer. Such program state information informs a fuzzer about where the magic bytes are located in the test input and how to perform\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:ZHo1McVdvXMC"}, {"title": "Hdskg: Harvesting domain specific knowledge graph from content of webpages", "description": "Knowledge graph is useful for many different domains like search result ranking, recommendation, exploratory search, etc. It integrates structural information of concepts across multiple information sources, and links these concepts together. The extraction of domain specific relation triples (subject, verb phrase, object) is one of the important techniques for domain specific knowledge graph construction. In this research, an automatic method named HDSKG is proposed to discover domain specific concepts and their relation triples from the content of webpages. We incorporate the dependency parser with rule-based method to chunk the relations triple candidates, then we extract advanced features of these candidate relation triples to estimate the domain relevance by a machine learning algorithm. For the evaluation of our method, we apply HDSKG to Stack Overflow (a Q&A website about computer programming). As\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:cFHS6HbyZ2cC"}, {"title": "A real-time and fully distributed approach to motion planning for multirobot systems", "description": "Motion planning is one of the most critical problems in multirobot systems. The basic target is to generate a collision-free trajectory for each robot from its initial position to the target position. In this paper, we study the trajectory planning for the multirobot systems operating in unstructured and changing environments. Each robot is equipped with some sensors of limited sensing ranges. We propose a fully distributed approach to planning trajectories for such systems. It combines the model predictive control (MPC) strategy and the incremental sequential convex programming (iSCP) method. The MPC framework is applied to detect the local running environment real-timely with the concept of receding horizon. For each robot, a nonlinear programming is built in its current prediction horizon. To construct its own optimization problem, a robot first needs to communicate with its neighbors to retrieve their current states\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:zA6iFVUQeVQC"}, {"title": "Automatic loop-invariant generation anc refinement through selective sampling", "description": "Automatic loop-invariant generation is important in program analysis and verification. In this paper, we propose to generate loop-invariants automatically through learning and verification. Given a Hoare triple of a program containing a loop, we start with randomly testing the program, collect program states at run-time and categorize them based on whether they satisfy the invariant to be discovered. Next, classification techniques are employed to generate a candidate loop-invariant automatically. Afterwards, we refine the candidate through selective sampling so as to overcome the lack of sufficient test cases. Only after a candidate invariant cannot be improved further through selective sampling, we verify whether it can be used to prove the Hoare triple. If it cannot, the generated counterexamples are added as new tests and we repeat the above process. Furthermore, we show that by introducing a path-sensitive\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:3s1wT3WcHBgC"}, {"title": "FiB: Squeezing loop invariants by interpolation between forward/backward predicate transformers", "description": "Loop invariant generation is a fundamental problem in program analysis and verification. In this work, we propose a new approach to automatically constructing inductive loop invariants. The key idea is to aggressively squeeze an inductive invariant based on Craig interpolants between forward and backward reachability analysis. We have evaluated our approach by a set of loop benchmarks, and experimental results show that our approach is promising.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:u_35RYKgDlwC"}, {"title": "Learning-based compositional parameter synthesis for event-recording automata", "description": "We address the verification of timed concurrent systems with unknown or uncertain constants considered as parameters. First, we introduce parametric event-recording automata (PERAs), as a new subclass of parametric timed automata (PTAs). Although in the non-parametric setting event-recording automata yield better decidability results than timed automata, we show that the most common decision problem remains undecidable for PERAs. Then, given one set of components with parameters and one without, we propose a method to compute an abstraction of the non-parametric set of components, so as to improve the verification of reachability properties in the full (parametric) system. We also show that our method can be extended to general PTAs. We implemented our method, which shows promising results.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:HoB7MX3m0LUC"}, {"title": "Loopster: Static loop termination analysis", "description": "Loop termination is an important problem for proving the correctness of a system and ensuring that the system always reacts. Existing loop termination analysis techniques mainly depend on the synthesis of ranking functions, which is often expensive. In this paper, we present a novel approach, named Loopster, which performs an efficient static analysis to decide the termination for loops based on path termination analysis and path dependency reasoning. Loopster adopts a divide-and-conquer approach: (1) we extract individual paths from a target multi-path loop and analyze the termination of each path, (2) analyze the dependencies between each two paths, and then (3) determine the overall termination of the target loop based on the relations among paths. We evaluate Loopster by applying it on the loop termination competition benchmark and three real-world projects. The results show that Loopster is effective\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:rO6llkc54NcC"}, {"title": "Process patterns: reusable design artifacts for business process models", "description": "Graphical models for business processes are very large and cumbersome to build. Reusable process patterns can make this modeling task much easier. While using reusable components is a well-explored subject in software engineering, not much has been done in the context of business process modeling. In this paper, we will present an extension to Business Process Model and Notation (BPMN), the standard notation for modeling business processes, in the form of reusable Process Patterns. We introduce a type system for these patterns and use it to define a valid embedding of a process pattern in a larger model. We also introduce the formal notations and show that business processes modeled using our extended notation can be translated to BPMN. We present a case study to demonstrate the applicability of the process pattern and further quantify its characteristics using a set of criteria. We also implement\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:fPk4N6BV_jEC"}, {"title": "Enhancing knowledge sharing in stack overflow via automatic external web resources linking", "description": "Referencing URLs of external web resources (e.g., official language references and API documents) is an effective mechanism for knowledge sharing in Q&A websites like Stack Overflow. We show that reference frequencies of URLs follow power law distribution, meaning that web resources that have been referenced frequently will likely to be referenced again. However, there lack of effective methods to manage and reuse already-shared web resources relevant to entities (e.g., APIs or programming concepts) that are mentioned in Q&A discussions. As URL references are done in an ad-hoc manner, large amounts of entity mentions have not been linked to relevant web resources. To enhance management and reuse of alreadyshared web resources in Stack Overflow, we build a knowledge base of official documentation of languages and APIs that have been shared in Stack Overflow, and develop an automatic\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:dfsIfKJdRG4C"}], "2021": [{"title": "A survey of smart contract formal specification and verification", "description": "A smart contract is a computer program that allows users to automate their actions on the blockchain platform. Given the significance of smart contracts in supporting important activities across industry sectors including supply chain, finance, legal, and medical services, there is a strong demand for verification and validation techniques. Yet, the vast majority of smart contracts lack any kind of formal specification, which is essential for establishing their correctness. In this survey, we investigate formal models and specifications of smart contracts presented in the literature and present a systematic overview to understand the common trends. We also discuss the current approaches used in verifying such property specifications and identify gaps with the hope to recognize promising directions for future work.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:8AbLer7MMksC"}, {"title": "Pasadena: Perceptually Aware and Stealthy Adversarial Denoise Attack", "description": "Image denoising can remove natural noise that widely exists in images captured by multimedia devices due to low-quality imaging sensors, unstable image transmission processes, or low light conditions. Recent works also find that image denoising benefits the high-level vision tasks,  e.g ., image classification. In this work, we try to challenge this common sense and explore a totally new problem,  i.e ., whether the image denoising can be given the capability of fooling the state-of-the-art deep neural networks (DNNs) while enhancing the image quality. To this end, we initiate the very first attempt to study this problem from the perspective of adversarial attack and propose the  adversarial denoise attack . More specifically, our main contributions are three-fold:  First , we identify a new task that stealthily embeds attacks inside the image denoising module widely deployed in multimedia devices as an image post\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:HE397vMXCloC"}, {"title": "Formal analysis of composable DeFi protocols", "description": "Decentralized finance (DeFi) has become one of the most successful applications of blockchain and smart contracts. The DeFi ecosystem enables a wide range of crypto-financial activities, while the underlying smart contracts often contain bugs, with many vulnerabilities arising from the unforeseen consequences of composing DeFi protocols together. In this paper, we propose a formal process-algebraic technique that models DeFi protocols in a compositional manner to allow for efficient property verification. We also conduct a case study to demonstrate the proposed approach in analyzing the composition of two interacting DeFi protocols, namely, Curve and Compound. Finally, we discuss how the proposed modeling and verification approach can be used to analyze financial and security properties of interest.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:geHnlv5EZngC"}, {"title": "CSim2 Compositional Top-down Verification of Concurrent Systems using Rely-Guarantee", "description": "To make feasible and scalable the verification of large and complex concurrent systems, it is necessary the use of compositional techniques even at the highest abstraction layers. When focusing on the lowest software abstraction layers, such as the implementation or the machine code, the high level of detail of those layers makes the direct verification of properties very difficult and expensive. It is therefore essential to use techniques allowing to simplify the verification on these layers. One technique to tackle this challenge is top-down verification where by means of simulation properties verified on top layers (representing abstract specifications of a system) are propagated down to the lowest layers (that are an implementation of the top layers). There is no need to say that simulation of concurrent systems implies a greater level of complexity, and having compositional techniques to check simulation between layers\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:sSrBHYA8nusC"}, {"title": "A security type verifier for smart contracts", "description": "The widespread adoption of smart contracts demands strong security guarantees. Our work is motivated by the problem of statically checking potential information tampering in smart contracts. This paper presents a security type verification framework for smart contracts based on type systems. We introduce a formal calculus for reasoning smart contract operations and interactions and design a lightweight type system for checking secure information flow in Solidity (a popular high-level programming language for writing smart contracts). The soundness of our type system is proved wrt non-interference. In addition, a type verifier based on our type system is proposed to assist users to automatically find an optimal secure type assignment for state variables, which makes contracts well-typed. We also prove that finding the optimal secure type assignment is theoretically a NP-complete problem. We develop a prototype\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:D_sINldO8mEC"}, {"title": "Automatic HMI structure exploration via curiosity-based reinforcement learning", "description": "Discovering the underlying structure of HMI software efficiently and sufficiently for the purpose of testing without any prior knowledge on the software logic remains a difficult problem. The key challenge lies in the complexity of the HMI software and the high variance in the coverage of current methods. In this paper, we introduce the PathFinder, an effective and automatic HMI software exploration framework. PathFinder adopts a curiosity-based reinforcement learning framework to choose actions that lead to the discovery of more unknown states. Additionally, PathFinder progressively builds a navigation model during the exploration to further improve state coverage. We have conducted experiments on both simulations and real-world HMI software testing environment, which comprise a full tool chain of automobile dashboard instrument cluster. The exploration coverage outperforms manual and fuzzing methods\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:kRWSkSYxWN8C"}, {"title": "Defense for adversarial videos by self-adaptive JPEG compression and optical texture", "description": "Despite demonstrated outstanding effectiveness in various computer vision tasks, Deep Neural Networks (DNNs) are known to be vulnerable to adversarial examples. Nowadays, adversarial attacks as well as their defenses w.r.t. DNNs in image domain have been intensively studied, and there are some recent works starting to explore adversarial attacks w.r.t. DNNs in video domain. However, the corresponding defense is rarely studied. In this paper, we propose a new two-stage framework for defending video adversarial attack. It contains two main components, namely self-adaptive Joint Photographic Experts Group (JPEG) compression defense and optical texture based defense (OTD). In self-adaptive JPEG compression defense, we propose to adaptively choose an appropriate JPEG quality based on an estimation of moving foreground object, such that the JPEG compression could depress most impact of\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:eJXPG6dFmWUC"}], "2020": [{"title": "Semantic understanding of smart contracts: Executable operational semantics of solidity", "description": "Bitcoin has been a popular research topic recently. Ethereum (ETH), a second generation of cryptocurrency, extends Bitcoin's design by offering a Turing-complete programming language called Solidity to develop smart contracts. Smart contracts allow creditable execution of contracts on EVM (Ethereum Virtual Machine) without third parties. Developing correct and secure smart contracts is challenging due to the decentralized computation nature of the blockchain. Buggy smart contracts may lead to huge financial loss. Furthermore, smart contracts are very hard, if not impossible, to patch once they are deployed. Thus, there is a recent surge of interest in analyzing and verifying smart contracts. While most of the existing works either focus on EVM bytecode or translate Solidity smart contracts into programs in intermediate languages, we argue that it is important and necessary to understand and formally define the\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:OU6Ihb5iCvQC"}, {"title": "A Performance-Sensitive Malware Detection System Using Deep Learning on Mobile Devices", "description": "Currently, Android malware detection is mostly performed on server side against the increasing number of malware. Powerful computing resource provides more exhaustive protection for app markets than maintaining detection by a single user. However, apart from the applications (apps) provided by the official market (i.e., Google Play Store), apps from unofficial markets and third-party resources are always causing serious security threats to end-users. Meanwhile, it is a time-consuming task if the app is downloaded first and then uploaded to the server side for detection, because the network transmission has a lot of overhead. In addition, the uploading process also suffers from the security threats of attackers. Consequently, a last line of defense on mobile devices is necessary and much-needed. In this paper, we propose an effective Android malware detection system, MobiTive, leveraging customized deep\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:uWQEDVKXjbEC"}, {"title": "Oracle-supported dynamic exploit generation for smart contracts", "description": "Despite the high stakes involved in smart contracts, they are often developed in an undisciplined manner, leaving the security and reliability of blockchain transactions at risk. In this article, we introduce ContraMaster\u2014an oracle-supported dynamic exploit generation framework for smart contracts. Existing approaches mutate only single transactions; ContraMaster exceeds these by mutating the transaction sequences. ContraMaster uses data-flow, control-flow, and the dynamic contract state to guide its mutations. It then monitors the executions of target contract programs, and validates the results against a general-purpose semantic test oracle to discover vulnerabilities. Being a dynamic technique, it guarantees that each discovered vulnerability is a violation of the test oracle and is able to generate the attack script to exploit this vulnerability. In contrast to rule-based approaches, ContraMaster has not shown any\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:1sJd4Hv_s6UC"}, {"title": "Adversarial exposure attack on diabetic retinopathy imagery", "description": "Diabetic retinopathy (DR) is a leading cause of vision loss in the world and numerous cutting-edge works have built powerful deep neural networks (DNNs) to automatically classify the DR cases via the retinal fundus images (RFIs). However, RFIs are usually affected by the widely existing camera exposure while the robustness of DNNs to the exposure is rarely explored. In this paper, we study this problem from the viewpoint of adversarial attack and identify a totally new task, i.e., adversarial exposure attack generating adversarial images by tuning image exposure to mislead the DNNs with significantly high transferability. To this end, we first implement a straightforward method, i.e., multiplicative-perturbation-based exposure attack, and reveal the big challenges of this new task. Then, to make the adversarial image naturalness, we propose the adversarial bracketed exposure fusion that regards the exposure attack as an element-wise bracketed exposure fusion problem in the Laplacian-pyramid space. Moreover, to realize high transferability, we further propose the convolutional bracketed exposure fusion where the element-wise multiplicative operation is extended to the convolution. We validate our method on the real public DR dataset with the advanced DNNs, e.g., ResNet50, MobileNet, and EfficientNet, showing our method can achieve high image quality and success rate of the transfer attack. Our method reveals the potential threats to the DNN-based DR automated diagnosis and can definitely benefit the development of exposure-robust automated DR diagnosis method in the future.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:ZuybSZzF8UAC"}, {"title": "A distributed method to avoid higher-order deadlocks in multi-robot systems", "description": "Deadlock avoidance is a crucial problem in motion control of multi-robot systems since deadlocks can crash the systems and\u2215 or degrade their performance. However, deadlocks sometimes are difficult to predict in advance because of the existence of higher-order deadlocks, from which a system can lead to a deadlock inevitably. In this paper, we investigate the properties of higher-order deadlocks and propose a distributed approach to their avoidance in multi-robot systems where each robot has a predetermined and closed path to execute persistent motion. After modeling the motion of robots by labeled transition systems (LTSs), we first conclude that there exist at most the (N\u2212 3)-th order deadlocks with N robots. This means that deadlocks, if any, will occur unavoidably within N\u2212 3 steps of corresponding transitions. A distributed algorithm is then proposed to avoid deadlocks in such systems. In the algorithm\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:UxriW0iASnsC"}, {"title": "ModCon: A model-based testing platform for smart contracts", "description": "Unlike those on public permissionless blockchains, smart contracts on enterprise permissioned blockchains are not limited by resource constraints, and therefore often larger and more complex. Current testing and analysis tools lack support for such contracts, which demonstrate stateful behaviors and require special treatment in quality assurance. In this paper, we present a model-based testing platform, called ModCon, relying on user-specified models to define test oracles, guide test generation, and measure test adequacy. ModCon is Web-based and supports both permissionless and permissioned blockchain platforms. We demonstrate the usage and key features of ModCon on real enterprise smart contract applications.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:738O_yMBCRsC"}, {"title": "A Generalized Formal Semantic Framework for Smart Contracts.", "description": "Smart contracts can be regarded as one of the most popular blockchain-based applications. The decentralized nature of the blockchain introduces vulnerabilities absent in other programs. Furthermore, it is very difficult, if not impossible, to patch a smart contract after it has been deployed. Therefore, smart contracts must be formally verified before they are deployed on the blockchain to avoid attacks exploiting these vulnerabilities. There is a recent surge of interest in analyzing and verifying smart contracts. While most of the existing works either focus on EVM bytecode or translate Solidity contracts into programs in intermediate languages for analysis and verification, we believe that a direct executable formal semantics of the high-level programming language of smart contracts is necessary to guarantee the validity of the verification. In this work, we propose a generalized formal semantic framework based on a general semantic model of smart contracts. Furthermore, this framework can directly handle smart contracts written in different high-level programming languages through semantic extensions and facilitates the formal verification of security properties with the generated semantics.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:SP6oXDckpogC"}, {"title": "SeqMobile: An Efficient Sequence-Based Malware Detection System Using RNN on Mobile Devices", "description": "With the proliferation of Android malware, the demand for an effective and efficient malware detection system is on the rise. The existing device-end learning based solutions tend to extract limited syntax features, such as permissions and API calls, to meet a certain time constraint of mobile devices. However, unlike sequence-based features, syntax features lack the semantics which can represent the potential malicious behaviors and further result in more robust model with high accuracy for malware detection. In this paper, we propose an efficient Android malware detection system, named SeqMobile, which adopts behavior-based sequence features and leverages customized deep neural networks on mobile devices instead of the server end. Different from the traditional sequence-based approaches on server end, to meet the performance demand on mobile devices, SeqMobile accepts three effective performance\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:4fKUyHm3Qg0C"}, {"title": "Towards automated verification of smart contract fairness", "description": "Smart contracts are computer programs allowing users to define and execute transactions automatically on top of the blockchain platform. Many of such smart contracts can be viewed as games. A game-like contract accepts inputs from multiple participants, and upon ending, automatically derives an outcome while distributing assets according to some predefined rules. Without clear understanding of the game rules, participants may suffer from fraudulent advertisements and financial losses. In this paper, we present a framework to perform (semi-)automated verification of smart contract fairness, whose results can be used to refute false claims with concrete examples or certify contract implementations with respect to desired fairness properties. We implement FairCon, which is able to check fairness properties including truthfulness, efficiency, optimality, and collusion-freeness for Ethereum smart contracts. We\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:Tiz5es2fbqcC"}, {"title": "Automatic verification of multi-threaded programs by inference of rely-guarantee specifications", "description": "Rely-Guarantee is a comprehensive technique that supports compositional reasoning for concurrent programs. However, specifications of the Rely condition - environment interference, and Guarantee condition - local transformation of thread state - are challenging to establish. Thus the construction of these conditions becomes bottleneck in automating the technique. To tackle the above problem, we propose a verification framework that, based on Rely-Guarantee principles, constructs the correctness proof of concurrent program through inferring suitable Rely -Guarantee conditions automatically. Our framework first constructs a Hoare-style sequential proof for each thread and then applies abstraction refinement to elevate these proofs into concurrent ones with appropriate Rely-Guarantee relations. Experiment results demonstrate that our approach is efficient in proving the correctness of concurrent programs.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:VOx2b1Wkg3QC"}], "2019": [{"title": "Vultron: catching vulnerable smart contracts once and for all", "description": "Despite the high stakes involved, smart contracts are often developed in an undisciplined way thus far. The existence of vulnerabilities compromises the security and reliability of smart contracts, and endangers the trust of participants in their ongoing businesses. Existing vulnerability detection techniques are often designed case-by-case, making them difficult to generalize. In this paper, we design general principles for detecting vulnerable smart contracts. Our key insight is that almost all the existing transaction-related vulnerabilities are due to the mismatch between the actual transferred amount and the amount reflected on the contract's internal bookkeeping. Based on this, we propose a precise and generally applicable technique, VULTRON, which can detect irregular transactions due to various types of adversarial exploits. We also report preliminary results applying our technique to real-world case studies.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:CHSYGLWDkRkC"}, {"title": "A neural model for method name generation from functional description", "description": "The names of software artifacts, e.g., method names, are important for software understanding and maintenance, as good names can help developers easily understand others\u2019 code. However, the existing naming guidelines are difficult for developers, especially novices, to come up with meaningful, concise and compact names for the variables, methods, classes and files. With the popularity of open source, an enormous amount of project source code can be accessed, and the exhaustiveness and instability of manually naming methods could now be relieved by automatically learning a naming model from a large code repository. Nevertheless, building a comprehensive naming system is still challenging, due to the gap between natural language functional descriptions and method names. Specifically, there are three challenges: how to model the relationship between the functional descriptions and formal method\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:abG-DnoFyZgC"}, {"title": "Mobidroid: A performance-sensitive malware detection system on mobile platform", "description": "Currently, Android malware detection is mostly performed on the server side against the increasing number of Android malware. Powerful computing resource gives more exhaustive protection for Android markets than maintaining detection by a single user in many cases. However, apart from the Android apps provided by the official market (i.e., Google Play Store), apps from unofficial markets and third-party resources are always causing a serious security threat to end-users. Meanwhile, it is a time-consuming task if the app is downloaded first and then uploaded to the server side for detection because the network transmission has a lot of overhead. In addition, the uploading process also suffers from the threat of attackers. Consequently, a last line of defense on Android devices is necessary and much-needed. To address these problems, in this paper, we propose an effective Android malware detection system\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:P5F9QuxV20EC"}, {"title": "Locating vulnerabilities in binaries via memory layout recovering", "description": "Locating vulnerabilities is an important task for security auditing, exploit writing, and code hardening. However, it is challenging to locate vulnerabilities in binary code, because most program semantics (e.g., boundaries of an array) is missing after compilation. Without program semantics, it is difficult to determine whether a memory access exceeds its valid boundaries in binary code. In this work, we propose an approach to locate vulnerabilities based on memory layout recovery. First, we collect a set of passed executions and one failed execution. Then, for passed and failed executions, we restore their program semantics by recovering fine-grained memory layouts based on the memory addressing model. With the memory layouts recovered in passed executions as reference, we can locate vulnerabilities in failed execution by memory layout identification and comparison. Our experiments show that the proposed\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:xtRiw3GOFMkC"}, {"title": "Learning performance optimization from code changes for android apps", "description": "Performance issues of Android apps can tangibly degrade user experience. However, it is challenging for Android developers, especially a novice to develop high-performance apps. It is primarily attributed to the lack of consolidated and abundant programmatic guides for performance optimization. To address this challenge, we propose a data-based approach to obtain performance optimization practices from historical code changes. We first elicit performance-aware Android APIs of which invocations could affect app performance to a large extent, identify historical code changes that produce impact on app performance, and further determine whether they are optimization practices. We have implemented this approach with a tool \\tool and evaluated its effectiveness in 2 open source well-maintained projects. The experimental results found 83 changes relevant to performance optimization. Last, we summarize and\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:NhqRSupF_l8C"}, {"title": "A performance-sensitive malware detection system on mobile platform", "description": "Apart from the Android apps provided by the official market, apps from unofficial markets and third-party resources are always causing a serious security threat to end-users. Because of the overhead of the network, uploading the app to the server for detection is a time-consuming task. In addition, the uploading process also suffers from the threat of attackers. Consequently, a last line of defense on Android devices is necessary and much-needed. To address these problems, we propose an effective Android malware detection system, leveraging deep learning to provide a real-time secure and fast response environment on Android devices.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:nb7KW1ujOQ8C"}], "2004": [{"title": "VERTAF: An application framework for the design and verification of embedded real-time software", "description": "The growing complexity of embedded real-time software requirements calls for the design of reusable software components, the synthesis and generation of software code, and the automatic guarantee of nonfunctional properties such as performance, time constraints, reliability, and security. Available application frameworks targeted at the automatic design of embedded real-time software are poor in integrating functional and nonfunctional requirements. To bridge this gap, we reveal the design flow and the internal architecture of a newly proposed framework called verifiable embedded real-time application framework (VERTAF), which integrates software component-based reuse, formal synthesis, and formal verification. A formal UML-based embedded real-time object model is proposed for component reuse. Formal synthesis employs quasistatic and quasidynamic scheduling with automatic generation of\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:u5HHmVD_uO8C"}, {"title": "Formal design and verification of real-time embedded software", "description": "Currently available application frameworks that target at the automatic design of real-time embedded software are poor in integrating functional and non-functional requirements. In this work, we reveal the internal architecture and design flow of a newly proposed framework called Verifiable Embedded Real-Time Application Framework (VERTAF), which integrates three techniques namely software component-based reuse, formal synthesis, and formal verification. Component reuse is based on a formal UML real-time embedded object model. Formal synthesis employs quasi-static and quasi-dynamic scheduling with multi-layer portable efficient code generation, which can output either RTOS-specific application code or automatically-generated real-time executive with application code. Formal verification integrates a model checker kernel from SGM, by adapting it for embedded software. The proposed\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:Y0pCki6q_DkC"}, {"title": "Automatic synthesis and verification of Real-Time Embedded software", "description": "Currently available application frameworks that target at the automatic design of real-time embedded software are poor in integrating functional and non-functional requirements. In this work, we reveal the internal architecture and design flow of a newly proposed framework called Verifiable Embedded Real-Time Application Framework (VERTAF), which integrates software component-based reuse, formal synthesis, and formal verification. Component reuse is based on a formal UML real-time embedded object model. Formal synthesis employs quasi-static and quasi-dynamic scheduling with multi-layer portable efficient code generation, which can output either RTOS-specific application code or automatically-generated real-time executive with application code. Formal verification integrates a model checker kernel from SGM, by adapting it for embedded software. Application examples developed using\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:5awf1xo2G04C"}], "2018": [{"title": "A distributed approach to robust control of multi-robot systems", "description": "Motion planning of multi-robot systems has been extensively investigated. Many proposed approaches assume that all robots are reliable. However, robots with priori known levels of reliability may be used in applications to account for: (1) the cost in terms of unit price per robot type, and (2) the cost in terms of robot wear in long term deployment. In the former case, higher reliability comes at a higher price, while in the latter replacement may cost more than periodic repairs, e.g., buses, trams, and subways. In this study, we investigate robust control of multi-robot systems, such that the number of robots affected by the failed ones is minimized. It should mandate that the failure of a robot can only affect the motion of robots that collide directly with the failed one. We assume that the robots in a system are divided into reliable and unreliable ones, and each robot has a predetermined and closed path to execute persistent\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:_xSYboBqXhAC"}, {"title": "Quasi-open bisimilarity with mismatch is intuitionistic", "description": "Quasi-open bisimilarity is the coarsest notion of bisimilarity for the \u03c0-calculus that is also a congruence. This work extends quasi-open bisimilarity to handle mismatch (guards with inequalities). This minimal extension of quasi-open bisimilarity allows fresh names to be manufactured to provide constructive evidence that an inequality holds. The extension of quasi-open bisimilarity is canonical and robust --- coinciding with open barbed bisimilarity (an objective notion of bisimilarity congruence) and characterised by an intuitionistic variant of an established modal logic. The more famous open bisimilarity is also considered, for which the coarsest extension for handling mismatch is identified. Applications to checking privacy properties are highlighted. Examples and soundness results are mechanised using the proof assistant Abella.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:f2IySw72cVMC"}, {"title": "APIReal: an API recognition and linking approach for online developer forums", "description": "When discussing programming issues on social platforms (e.g, Stack Overflow, Twitter), developers often mention APIs in natural language texts. Extracting API mentions from natural language texts serves as the prerequisite to effective indexing and searching for API-related information in software engineering social content. The task of extracting API mentions from natural language texts involves two steps: 1) distinguishing API mentions from other English words (i.e., API recognition), 2) disambiguating a recognized API mention to its unique fully qualified name (i.e., API linking). Software engineering social content lacks consistent API mentions and sentence writing format. As a result, API recognition and linking have to deal with the inherent ambiguity of API mentions in informal text, for example, due to the ambiguity between the API sense of a common word and the normal sense of the word (e.g\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:yD5IFk8b50cC"}, {"title": "Compositional reasoning for shared-variable concurrent programs", "description": "Scalable and automatic formal verification for concurrent systems is always demanding. In this paper, we propose a verification framework to support automated compositional reasoning for concurrent programs with shared variables. Our framework models concurrent programs as succinct automata and supports the verification of multiple important properties. Safety verification and simulations of succinct automata are parallel compositional, and safety properties of succinct automata are preserved under refinements. We generate succinct automata from infinite state concurrent programs in an automated manner. Furthermore, we propose the first automated approach to checking rely-guarantee based simulations between infinite state concurrent programs. We have prototyped our algorithms and applied our tool to the verification of multiple refinements.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:b0M2c_1WBrUC"}, {"title": "The language preservation problem is undecidable for parametric event-recording automata", "description": "Parametric timed automata (PTA) extend timed automata with unknown constants (\u201cparameters\u201d), at the price of undecidability of most interesting problems. The (untimed) language preservation problem (\u201cgiven a parameter valuation, can we find at least one other valuation with the same untimed language?\u201d) is undecidable for PTAs. We prove that this problem remains undecidable for parametric event-recording automata (PERAs), a subclass of PTAs that considerably restrains the way the language can be used; we also show it remains undecidable even for slightly different definitions of the language, i.e., finite sequences of actions ending in or passing infinitely often through accepting locations, or just all finite untimed words (without accepting locations).", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:a0OBvERweLwC"}, {"title": "An Executable Operational Semantics for Rust with the Formalization of Ownership and Borrowing", "description": "Rust is an emergent systems programming language highlighting memory safety by its Ownership and Borrowing System (OBS). The existing formal semantics for Rust only covers limited subsets of the major language features of Rust. Moreover, they formalize OBS as type systems at the language-level, which can only be used to conservatively analyze programs against the OBS invariants at compile-time. That is, they are not executable, and thus cannot be used for automated verification of runtime behavior. In this paper, we propose RustSEM, a new executable operational semantics for Rust. RustSEM covers a much larger subset of the major language features than existing semantics. Moreover, RustSEM provides an operational semantics for OBS at the memory-level, which can be used to verify the runtime behavior of Rust programs against the OBS invariants. We have implemented RustSEM in the executable semantics modeling tool K-Framework. We have evaluated the semantics correctness of RustSEM wrt. the Rust compiler using around 700 tests. In particular, we have proposed a new technique for testing semantic consistency to ensure the absence of semantic ambiguities on all possible execution selections. We have also evaluated the potential applications of RustSEM in automated runtime and formal verification for both functional and memory properties. Experimental results show that RustSEM can enhance the memory safety mechanism of Rust, as it is more powerful than OBS in detecting memory errors.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:ye4kPcJQO24C"}], "2014": [{"title": "Learning Assumptions for Compositional Verification of Timed Systems", "description": "Compositional techniques such as assume-guarantee reasoning (AGR) can help to alleviate the state space explosion problem associated with model checking. However, compositional verification is difficult to be automated, especially for timed systems, because constructing appropriate assumptions for AGR usually requires human creativity and experience. To automate compositional verification of timed systems, we propose a compositional verification framework using a learning algorithm for automatic construction of timed assumptions for AGR. We prove the correctness and termination of the proposed learning-based framework, and experimental results show that our method performs significantly better than traditional monolithic timed model checking.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:0EnyYjriUFMC"}, {"title": "Diamonds are a girl\u2019s best friend: Partial order reduction for timed automata with abstractions", "description": "A major obstacle for using partial order reduction in the context of real time verification is that the presence of clocks and clock constraints breaks the usual diamond structure of otherwise independent transitions. This is especially true when information of the relative values of clocks is preserved in the form of diagonal constraints. However, when diagonal constraints are relaxed by a suitable abstraction, some diamond structure is re-introduced in the zone graph. In this article, we introduce a variant of the stubborn set method for reducing an abstracted zone graph. Our method works with all abstractions, but especially targets situations where one abstract execution can simulate several permutations of the corresponding concrete execution, even though it might not be able to simulate the permutations of the abstract execution. We define independence relations that capture this \u201chidden\u201d diamond structure\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:M3NEmzRMIkIC"}, {"title": "Compositional synthesis of concurrent systems through causal model checking and learning", "description": "Formal verification such as model checking can be used to verify whether a system model satisfies a given specification. However, if model checking shows that the system model violates the specification, the designer has to manually refine the system model. To automate this refinement process, we propose a learning-based synthesis framework that can automatically eliminate all counterexamples from a system model based on causality semantics such that the synthesized model satisfies a given safety specification. Further, the framework for synthesis is not only automatic, but is also an iterative compositional process based on the L* algorithm, i.e., the global state space of the system is never generated in the synthesis process. We also prove the correctness and termination of the synthesis framework.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:maZDTaKrznsC"}], "2013": [{"title": "Tzuyu: Learning stateful typestates", "description": "Behavioral models are useful for various software engineering tasks. They are, however, often missing in practice. Thus, specification mining was proposed to tackle this problem. Existing work either focuses on learning simple behavioral models such as finite-state automata, or relies on techniques (e.g., symbolic execution) to infer finite-state machines equipped with data states, referred to as stateful typestates. The former is often inadequate as finite-state automata lack expressiveness in capturing behaviors of data-rich programs, whereas the latter is often not scalable. In this work, we propose a fully automated approach to learn stateful typestates by extending the classic active learning process to generate transition guards (i.e., propositions on data states). The proposed approach has been implemented in a tool called TzuYu and evaluated against a number of Java classes. The evaluation results show that\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:j3f4tGmQtD8C"}, {"title": "PSyHCoS: parameter synthesis for hierarchical concurrent real-time systems", "description": "Real-time systems are often hard to control, due to their complicated structures, quantitative time factors and even unknown delays. We present here PSyHCoS, a tool for analyzing parametric real-time systems specified using the hierarchical modeling language PSTCSP. PSyHCoS supports several algorithms for parameter synthesis and model checking, as well as state space reduction techniques. Its architecture favors reusability in terms of syntax, semantics, and algorithms. It comes with a friendly user interface that can be used to edit, simulate and verify PSTCSP models. Experiments show its efficiency and applicability.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:M3ejUd6NZC8C"}, {"title": "CELL: A Compositional Verification Framework", "description": "This paper presents CELL, a comprehensive and extensible framework for compositional verification of concurrent and real-time systems based on commonly used semantic models. For each semantic model, CELL offers three libraries, i.e., compositional verification paradigms, learning algorithms and model checking methods to support various state-of-the-art compositional verification approaches. With well-defined APIs, the framework could be applied to build customized model checkers. In addition, each library could be used independently for verification and program analysis purposes. We have built three model checkers with CELL. The experimental results show that the performance of these model checkers can offer similar or often better performance compared to the state-of-the-art verification tools.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:TQgYirikUcIC"}, {"title": "Generating C# Programs from CSP# Models", "description": "Due to the inherent complexity of the concurrent behavior, it is difficult to ensure the program satisfies the concurrent properties. CSP#, as a formal language, is used to model the program and the properties can be verified on the CSP# model. It is desirable to have a transformation technique from the CSP# model to the implementation. We implement the CSP# operators in a C# library \u201cPAT.Runtime\u201d. Based on it, a code generation tool is developed in PAT framework to transform CSP# models to multi-threaded C# programs. We prove that the generated C# program and original CSP# model are equivalent on the traces semantics. The validated properties of the CSP# model preserve in the generated program.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:ZeXyd9-uunAC"}], "2011": [{"title": "An efficient algorithm for learning event-recording automata", "description": "In inference of untimed regular languages, given an unknown language to be inferred, an automaton is constructed to accept the unknown language from answers to a set of membership queries each of which asks whether a string is contained in the unknown language. One of the most well-known regular inference algorithms is the L* algorithm, proposed by Angluin in 1987, which can learn a minimal deterministic finite automaton (DFA) to accept the unknown language. In this work, we propose an efficient polynomial time learning algorithm, TL*, for timed regular language accepted by event-recording automata. Given an unknown timed regular language, TL* first learns a DFA accepting the untimed version of the timed language, and then passively refines the DFA by adding time constraints. We prove the correctness, termination, and minimality of the proposed TL* algorithm.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&citation_for_view=sCbkO2oAAAAJ:WF5omc3nYNoC"}, {"title": "VERTAF/Multi-Core: A SysML-based application framework for multi-core embedded software development", "description": "Multi-core processors are becoming prevalent rapidly in personal computing and embedded systems. Nevertheless, the programming environment for multi-core processor-based systems is still quite immature and lacks efficient tools. In this work, we present a new VERTAF/Multi-Core framework and show how software code can be automatically generated from SysML models of multi-core embedded systems. We illustrate how model-driven design based on SysML can be seamlessly integrated with Intel\u2019s threading building blocks (TBB) and the quantum framework (QF) middleware. We use a digital video recording system to illustrate the benefits of the framework. Our experiments show how SysML/QF/TBB help in making multi-core embedded system programming model-driven, easy, and efficient.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:2osOgNQ5qMEC"}, {"title": "Counterexample-guided assume-guarantee synthesis through learning", "description": "Assume-guarantee reasoning (AGR) is a promising compositional verification technique that can address the state space explosion problem associated with model checking. Since the construction of assumptions usually requires nontrivial human efforts, a framework was already proposed for generating assumptions automatically using the L* algorithm. However, if the framework shows that a system model does not satisfy a given specification, the designer has to manually refine the system model. To automate this refinement process, we propose a framework that can automatically eliminate all counterexamples from a system model such that the synthesized model satisfies a given safety specification. Further, the framework for synthesis is not only automatic, but is also an iterative L*-based compositional process, i.e., the global state space of the system is never generated in the synthesis process. When a model\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:Tyk-4Ss8FVUC"}, {"title": "SAT-based Verification of Data-Independent Access Control Security Systems", "description": "The Harrison-Ruzzo-Ullman problem is the verification of a set of policy rules, starting from an initial protection matrix, for the reachability of a state in which a generic access right is granted. Three decades ago, it was shown to be undecidable; however, recently Kleiner and Newcomb (KN) used communicating sequential processes to prove that the model checking of data-independent security systems against universal safety access temporal logic (SATL) is decidable. Nevertheless, this restricted KN problem still lacks an automatic verification method. As a solution, we modeled it as a satisfiability problem such that a set of policy rules can be model checked against a universal SATL property without explicitly constructing the state model a priori. This is made possible by a key technique called permission inheritance. Besides proving the correctness and termination of the proposed method, two real cases namely employee information system and nuclear power plant security system are also used to illustrate the feasibility and efficiency of the proposed method.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:hqOjcs7Dif8C"}, {"title": "Automatic High-Level Code Generation for Multi-Core Processors in Embedded Systems", "description": "This chapter demonstrates how high-level code is automatically generated for multi-core processors. The code generation capability of the Verifiable Embedded Real-Time Application Framework (VERTAF) was extended to support multi-core processors in the new VERTAF/Multi-Core (VMC) framework for embedded systems. After users specify embedded software requirements via SysML models along with parallel task, parallel data, and parallel dataflow specifications, the code generator automatically generates parallel code. Using the digital video recording (DVR) system as a case study, we show the correctness and advantages of the VMC code generator. The main inputs of VMC code generator include the block definition diagrams, state machine diagrams, and requirement diagrams of the system to be designed. The proposed code generation in VMC not only significantly decreases the amount of manually-written code, but also provides a formal procedure for model-conforming code generation of multi-core embedded software.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:eq2jaN3J8jMC"}, {"title": "Model-Driven Development of Multi-Core Embedded Software", "description": "Multi-core processors are becoming prevalent rapidly in personal computing and embedded systems. Nevertheless, the programming environment for multi-core processor based systems is still quite immature and lacks efficient tools. This chapter will propose a new framework called VERTAF/Multi-Core (VMC) and show how software code can be automatically generated from high-level SysML models of multi-core embedded systems. It will also illustrate how model-driven design based on SysML can be seamlessly integrated with Intel\u2019s Threading Building Blocks (TBB) and Quantum Platform (QP) middleware. Finally, this chapter will use a digital video recording (DVR) system to illustrate the benefits of the proposed VMC framework.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:p2g8aNsByqUC"}], "2005": [{"title": "Model checking prioritized timed automata", "description": "Priorities are often used to resolve conflicts in timed systems. However, priorities are not directly supported by state-of-art model checkers. Often, a designer has to either abstract the priorities leading to a high degree of non-determinism or model the priorities using existing primitives. In this work, it is shown how prioritized timed automata can make modelling prioritized timed systems easier through the support for priority specification and model checking. The verification of prioritized timed automata requires a subtraction operation to be performed on two clock zones, represented by DBMs, for which we propose an algorithm to generate the minimal number of zones partitioned. After the application of a series of DBM subtraction operations, the number of zones generated become large. We thus propose an algorithm to reduce the final number of zones partitioned by merging some of them. A typical bus\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:u-x6o8ySG0sC"}, {"title": "Model checking timed systems with priorities", "description": "Priorities are used to resolve conflicts such as in re-source sharing and in safety designs. The use of priorities has become indispensable in real-time system design such as in scheduling, synchronization, arbitration, and fairness guaranteeing. There are several modeling frameworks that show how timed systems with priorities are to be designed and how priority schedulers can be automatically synthesized. However, the verification of timed systems with priorities using model checking is still a relatively untouched area. We show what the issues are in model checking timed systems with priorities and how the issues are solved in this work. In the process, we propose an optimal zone subtraction algorithm. The method has been implemented into the SGM model checker and successfully applied to real-time embedded systems and safety-critical systems, which illustrate the feasibility and advantages of the proposed\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:9yKSN-GCB0IC"}], "2012": [{"title": "Automatic Compositional Verification of Timed Systems", "description": "Specification and verification of real-time systems are important research topics with crucial applications; however, the so-called state space explosion problem often prevents model checking to be used in practice for large systems. In this work, we present a self-contained toolkit to analyze real-time systems specified using event-recording automata (ERAs), which supports system modeling, animated simulation, and fully automatic compositional verification based on learning techniques. Experimental results show that our tool outperforms the state-of-the-art timed model checker.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:3fE2CSJIrl8C"}, {"title": "Automatic generation of provably correct embedded systems", "description": "With the demand for new and complicated features, embedded systems are becoming more and more difficult to design and verify. Even if the design of a system is verified, how to guarantee the consistency between the design and its implementation remains a big issue. As a solution, we propose a framework that can help a system designer to model his or her embedded system using a high-level modeling language, verify the design of the system, and automatically generate executable software codes whose behavior semantics are consistent with that of the high-level model. We use two case studies to demonstrate the effectiveness of our framework.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:MXK_kJrjxJIC"}, {"title": "Model Checking Prioritized Timed Systems", "description": "Real-time systems modeled by timed automata are often symbolically verified using Difference Bound Matrix (DBM) and Binary Decision Diagram (BDD) operations. When designing concurrent real-time systems with two or more processes sharing a resource, priorities are often used to schedule processes and to resolve conflicting resource requests. Concurrent real-time systems can thus be modeled by timed automata with priorities. However, model checking timed automata with priorities needs the DBM subtraction operation, whose result may not be convex, i.e., DBMs are not closed under subtraction. Thus, a partition of the resulting DBM is required. In this work, we propose Prioritized Timed Automata (PTA) and resolve all the issues related to the model checking of PTA. Two algorithms are proposed including an optimal DBM subtraction algorithm that produces the minimal number of DBM partitions, and a\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:LkGwnXOMwfcC"}], "2015": [{"title": "Interpolation guided compositional verification (t)", "description": "Model checking suffers from the state space explosion problem. Compositional verification techniques such as assume-guarantee reasoning (AGR) have been proposed to alleviate the problem. However, there are at least three challenges in applying AGR. Firstly, given a system M1 ? M2, how do we automatically construct and refine (in the presence of spurious counterexamples) an assumption A2, which must be an abstraction of M2? Previous approaches suggest to incrementally learn and modify the assumption through multiple invocations of a model checker, which could be often time consuming. Secondly, how do we keep the state space small when checking M1 ? A2 = f if multiple refinements of A2 are necessary? Lastly, in the presence of multiple parallel components, how do we partition the components? In this work, we propose interpolation-guided compositional verification. The idea is to tackle three\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:vV6vV6tmYwMC"}, {"title": "TLV: abstraction through testing, learning, and validation", "description": "A (Java) class provides a service to its clients (i.e., programs which use the class). The service must satisfy certain specifications. Different specifications might be expected at different levels of abstraction depending on the client's objective. In order to effectively contrast the class against its specifications, whether manually or automatically, one essential step is to automatically construct an abstraction of the given class at a proper level of abstraction. The abstraction should be correct (i.e., over-approximating) and accurate (i.e., with few spurious traces). We present an automatic approach, which combines testing, learning, and validation, to constructing an abstraction. Our approach is designed such that a large part of the abstraction is generated based on testing and learning so as to minimize the use of heavy-weight techniques like symbolic execution. The abstraction is generated through a process of abstraction\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:RYcK_YlVTxYC"}], "2022": [{"title": "Enhancing security patch identification by capturing structures in commits", "description": "With the rapid increasing number of open source software (OSS), the majority of the software vulnerabilities in the open source components are fixed silently, which leads to the deployed software that integrated them being unable to get a timely update. Hence, it is critical to design a security patch identification system to ensure the security of the utilized software. However, most of the existing works for security patch identification just consider the changed code and the commit message of a commit as a flat sequence of tokens with simple neural networks to learn its semantics, while the structure information is ignored. To address these limitations, in this paper, we propose our well-designed approach E-SPI, which extracts the structure information hidden in a commit for effective identification. Specifically, it consists of the code change encoder to extract the syntactic of the changed code with the BiLSTM to learn the\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:XiVPGOgt02cC", "topics": "Information Retrieval, Software Engineering"}, {"title": "Finding Permission Bugs in Smart Contracts with Role Mining", "description": "Smart contracts deployed on permissionless blockchains, such as Ethereum, are accessible to any user in a trustless environment. Therefore, most smart contract applications implement access control policies to protect their valuable assets from unauthorized accesses. A difficulty in validating the conformance to such policies, i.e., whether the contract implementation adheres to the expected behaviors, is the lack of policy specifications. In this paper, we mine past transactions of a contract to recover a likely access control model, which can then be checked against various information flow policies and identify potential bugs related to user permissions. We implement our role mining and security policy validation in tool SPCon. The experimental evaluation on labeled smart contract role mining benchmark demonstrates that SPCon effectively mines more accurate user roles compared to the state-of-the-art role mining\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:5ugPr518TE4C", "topics": "Access Control, Role Mining, Smart Contracts"}, {"title": "A quantum interpretation of separating conjunction for local reasoning of quantum programs based on separation logic", "description": "It is well-known that quantum programs are not only complicated to design but also challenging to verify because the quantum states can have exponential size and require sophisticated mathematics to encode and manipulate. To tackle the state-space explosion problem for quantum reasoning, we propose a Hoare-style inference framework that supports local reasoning for quantum programs. By providing a quantum interpretation of the separating conjunction, we are able to infuse separation logic into our framework and apply local reasoning using a quantum frame rule that is similar to the classical frame rule. For evaluation, we apply our framework to verify various quantum programs including Deutsch\u2013Jozsa\u2019s algorithm and Grover's algorithm.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:mvPsJ3kp5DgC", "topics": "Quantum Programming, Separation Logic, Local Reasoning"}, {"title": "SolSEE: a source-level symbolic execution engine for solidity", "description": "Most of the existing smart contract symbolic execution tools perform analysis on bytecode, which loses high-level semantic information presented in source code. This makes interactive analysis tasks\u2014such as visualization and debugging\u2014extremely challenging, and significantly limits the tool usability. In this paper, we present SolSEE, a source-level symbolic execution engine for Solidity smart contracts. We describe the design of SolSEE, highlight its key features, and demonstrate its usages through a Web-based user interface. SolSEE demonstrates advantages over other existing source-level analysis tools in the advanced Solidity language features it supports and analysis flexibility. A demonstration video is available at: https://sites.google.com/view/solsee/.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:olpn-zPbct0C", "topics": "Symbolic Execution, Smart Contracts, Solidity"}, {"title": "Property-Based Automated Repair of DeFi Protocols", "description": "Programming errors enable security attacks on smart contracts, which are used to manage large sums of financial assets. Automated program repair (APR) techniques aim to reduce developers\u2019 burden of manually fixing bugs by automatically generating patches for a given issue. Existing APR tools for smart contracts focus on mitigating typical smart contract vulnerabilities rather than violations of functional specification. However, in decentralized financial (DeFi) smart contracts, the inconsistency between intended behavior and implementation translates into the deviation from the underlying financial model, resulting in monetary losses for the application and its users. In this work, we propose DeFinery\u2014a technique for automated repair of a smart contract that does not satisfy a user-defined correctness property. To explore a larger set of diverse patches while providing formal correctness guarantees w.r.t. the\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:t6usbXjVLHcC", "topics": "Automated Program Repair, Smart Contracts, Decentralized Finance"}, {"title": "SMT Solver with Hardware Acceleration", "description": "Satisfiability modulo theories (SMT), an extension of Boolean satisfiability (SAT) problem, is widely used in many application domains because of its rich expressiveness. Thus, there are many works trying to speedup the process of SAT/SMT solving. In this work, we develop a framework by proposing a new hardware architecture to solve the SMT problem for the theory of Quantifier free Linear Real Arithmetic (QF-LRA) to speedup the SMT solving process. The new proposed architecture framework consists of a hardware SAT solver and a hardware Simplex solver. Our hardware SAT solver has an optimized BCP process with a pipeline structure and a non-chronological backtracking mechanism, while our hardware Simplex solver supports parallel operation flow inside the Simplex iteration to execute the selection operations parallelly with the pivot operation and the row selection mechanism to avoid unnecessary\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:Mojj43d5GZwC", "topics": "Hardware Acceleration, SMT Solver, SAT/SMT Solving"}, {"title": "Dynamic assertion for quantum circuits based on stabilizers", "description": "Quantum computing is computationally more powerful than classical one due to the features of superposition and entanglement of quantum bits (qubits). However, because of the non-cloning property, measuring qubits in superposition forces them to collapse onto classical ones, which makes traditional run-time techniques for debugging and analyzing hardware circuits infeasible. To overcome this issue, previous works proposed the concept of quantum dynamic runtime assertion. Stabilizer is an approach adopted for correcting quantum errors. The quantum state can remain unchanged after several Pauli operations. We call these Pauli operations a stabilizer. In this work, we propose to use the quantum stabilizers for dynamic runtime assertions, which requires less quantum gates and increases the detect accuracy on Noisy intermediate scale quantum(NISQ).", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:UHK10RUVsp4C", "topics": "Quantum Computing, Quantum Error Correction, Dynamic Runtime Assertion"}], "2009": [{"title": "Model-driven development of multi-core embedded software", "description": "Model-driven development is worthy of further research because of its proven capabilities in increasing productivity and ensuring correctness. However, it has not yet been explored for multi-core processor-based embedded systems, whose programming is even more complex and difficult that that for conventional uni-processor systems. We propose a new VERTAF/Multi-Core (VMC) framework to bridge this gap. In this work, we mainly show how VMC generates code automatically from user-specified SysML models for multi-core embedded systems. We illustrate how model-driven design based on SysML can be seamlessly integrated with Intels threading building blocks (TBB) and the Quantum Framework middleware. We use a digital video recording system to illustrate the benefits of VMC. Our experiments show how SysML/QF/TBB make multi-core embedded system programming easy, efficient, and effortless.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:zYLM7Y9cAGgC"}, {"title": "Vertaf/multi-core: A sysml-based application framework for multi-core embedded software development", "description": "Multi-core processors are becoming prevalent rapidly in personal computing and embedded systems. Nevertheless, the programming environment for multi-core processor based systems is still quite immature and lacks efficient tools. In this work, we present a new VERTAF/Multi-Core framework and show how software code can be automatically generated from SysML models of multi-core embedded systems. We illustrate how model-driven design based on SysML can be seamlessly integrated with Intel\u2019s threading building blocks (TBB) and the Quantum Platform middleware. We use a digital video recording system to illustrate the benefits of the framework. Our experiments show how SysML/QF/TBB help in making the multi-core embedded system programming model-driven, easy, efficient, and effortless.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:W7OEmFMy1HYC"}, {"title": "Modeling and verification of real-time embedded systems with urgency", "description": "Real-time embedded systems are often designed with different types of urgencies such as delayable or eager, that are modeled by several urgency variants of the timed automata model. However, most model checkers do not support such urgency semantics, except for the IF toolset that model checks timed automata with urgency against observers. This work proposes an Urgent Timed Automata (UTA) model with zone-based urgency semantics that gives the same model checking results as absolute urgency semantics of other existing urgency variants of the timed automata model, including timed automata with deadlines and timed automata with urgent transitions. A necessary and sufficient condition, called complete urgency, is formulated and proved for avoiding zone partitioning so that the system state graphs are simpler and model checking is faster. A novel zone capping method is proposed that is time\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:YsMSGLbcyi4C"}], "2010": [{"title": "Real-time embedded software design for mobile and ubiquitous systems", "description": "Currently available application frameworks that target at the automatic design of real-time embedded software are poor in integrating functional and non-functional requirements for mobile and ubiquitous systems. In this work, we present the internal architecture and design flow of a newly proposed framework called Verifiable Embedded Real-Time Application Framework (VERTAF), which integrates three techniques namely software component-based reuse, formal synthesis, and formal verification. The proposed architecture for VERTAF is component-based which allows plug-and-play for the scheduler and the verifier. The architecture is also easily extensible because reusable hardware and software design components can be added. Application examples developed using VERTAF demonstrate significantly reduced relative design effort, which shows how high-level reuse of software components\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:eQOLeE2rZwMC"}], "2008": [{"title": "Automatic synthesis and verification of real-time embedded software for mobile and ubiquitous systems", "description": "Currently available application frameworks that target the automatic design of real-time embedded software are poor in integrating functional and non-functional requirements for mobile and ubiquitous systems. In this work, we present the internal architecture and design flow of a newly proposed framework called Verifiable Embedded Real-Time Application Framework (VERTAF), which integrates three techniques namely software component-based reuse, formal synthesis, and formal verification. Component reuse is based on a formal unified modeling language (UML) real-time embedded object model. Formal synthesis employs quasi-static and quasi-dynamic scheduling with multi-layer portable efficient code generation, which can output either real-time operating systems (RTOS)-specific application code or automatically generated real-time executive with application code. Formal verification integrates a model\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:d1gkVwhDpl0C"}], "2016": [{"title": "From verified model to executable program: the PAT approach", "description": "CSP# is a formal modeling language that emphasizes the design of communication in concurrent systems. PAT framework provides a model checking environment for the simulation and verification of CSP# models. Although the desired properties can be formally verified at the design level, it is not always straightforward to ensure the correctness of the system\u2019s implementation conforms to the behaviors of the formal design model. To avoid human error and enhance productivity, it would be beneficial to have a tool support to automatically generate the executable programs from their corresponding formal models. In this paper, we propose such a solution for translating verified CSP# models into C# programs in the PAT framework. We encoded the CSP# operators in a C# library-\u201cPAT.Runtime\u201d, where the event synchronization is based on the \u201cMonitor\u201d class in C#. The precondition and choice layers are\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:lSLTfruPkqcC"}, {"title": "Engineering Socially-Aware Systems and Applications", "description": "With the convergence of pervasive mobile computing and social networking, interest has grown significantly in software systems and applications that are aware of users' social context to make pervasive applications more intelligent and accessible. Thus, socially-aware systems have further advanced context-aware systems taking account of human social context such as social relationships to enable the attainment of users' tasks in different domains. However, social context-awareness introduces a variety of software engineering challenges. In this paper, we address these challenges by proposing a software engineering process that provides a methodological framework for developing various types of socially-aware applications from requirements elicitation through to concrete implementation. We provide context models and software infrastructure to assist developers in rapid prototyping. We also present two\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:4OULZ7Gr8RgC"}], "2006": [{"title": "Model checking timed systems with urgencies", "description": "Computation tree logic (CTL) model checkers either allow modeling of only lazy semantics in the timed system model or consider at most a simple as soon as possible semantics. However, the design of real-time systems requires different types of urgencies, which have been modeled by several urgency variants of the timed automata model. Except for the IF toolset that model checks timed automata with urgency against observers, the urgency variants of timed automata have not yet been used for verifying the satisfaction of CTL properties in real-time systems. This work is targeted at proposing a zone-based urgency semantics that is time-reactive and at model checking timed automata models that have been extended with such urgency semantics for delayable and eager transition types. Interactions among these different types of transition urgencies are also investigated. The proposed verification\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:qjMakFHDy7sC"}], "2007": [{"title": "Real-time embedded software design for mobile and ubiquitous systems", "description": "Currently available application frameworks that target at the automatic design of real-time embedded software are poor in integrating functional and non-functional requirements for mobile and ubiquitous systems. In this work, we present the internal architecture and design flow of a newly proposed framework called Verifiable Embedded Real-Time Application Framework (VERTAF), which integrates three techniques namely software component-based reuse, formal synthesis, and formal verification. The proposed architecture for VERTAF is component-based which allows plug-and-play for the scheduler and the verifier. The architecture is also easily extensible because reusable hardware and software design components can be added. Application examples developed using VERTAF demonstrate significantly reduced relative design effort, which shows how high-level reuse of software components\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:SdhP9T11ey4C"}, {"title": "From ISA to application design via RTOS\u2014a course design framework for embedded software", "description": "Embedded systems have pervaded every aspect of our daily lives, however their design and verification are often accomplished using ad hoc and trial-and-error methods. Courses introducing systematic and more formal methods are required. However, currently there is little consensus on what a standard syllabus for an undergraduate course on embedded software design should cover. This paper proposes a course design that have undergone thorough experimentations and evaluations through the last four years in actual classes. The course starts from the ARM instruction set architecture and concludes with an introduction of Java-based wireless application design. The design of standalone, as well as, RTOS-based embedded software are all introduced. The course has culminated in the generation of embedded software engineers that significantly contribute to the technical industry in Taiwan, spanning from\u00a0\u2026", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:roLk4NBRz8UC"}], "2023": [{"title": "A Quantum SMT Solver for Bit-Vector Theory", "description": "Given a formula  of satisfiability modulo theory (SMT), the classical SMT solver tries to (1) abstract  as a Boolean formula , (2) find a Boolean solution to , and (3) check whether the Boolean solution is consistent with the theory. Steps~{(2)} and (3) may need to be performed back and forth until a consistent solution is found. In this work, we develop a quantum SMT solver for the bit-vector theory. With the characteristic of superposition in quantum system, our solver is able to consider all the inputs simultaneously and check their consistency between Boolean and the theory domains in one shot.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:LjlpjdlvIbIC", "topics": "Quantum Computing, Satisfiability Modulo Theory, Bit-Vector Theory"}, {"title": "A Parallel and Distributed Quantum SAT Solver Based on Entanglement and Quantum Teleportation", "description": "Boolean satisfiability (SAT) solving is a fundamental problem in computer science. Finding efficient algorithms for SAT solving has broad implications in many areas of computer science and beyond. Quantum SAT solvers have been proposed in the literature based on Grover's algorithm. Although existing quantum SAT solvers can consider all possible inputs at once, they evaluate each clause in the formula one by one sequentially, making the time complexity O(m) -- linear to the number of clauses m -- per Grover iteration. In this work, we develop a parallel quantum SAT solver, which reduces the time complexity in each iteration from linear time O(m) to constant time O(1) by utilising extra entangled qubits. To further improve the scalability of our solution in case of extremely large problems, we develop a distributed version of the proposed parallel SAT solver based on quantum teleportation such that the total qubits required are shared and distributed among a set of quantum computers (nodes), and the quantum SAT solving is accomplished collaboratively by all the nodes. We have proved the correctness of our approaches and demonstrated them in simulations.", "link": "https://scholar.google.com/citations?view_op=view_citation&hl=en&user=sCbkO2oAAAAJ&cstart=20&pagesize=80&citation_for_view=sCbkO2oAAAAJ:W5xh706n7nkC", "topics": "Parallel Computing, Distributed Computing, Quantum Computing"}]}